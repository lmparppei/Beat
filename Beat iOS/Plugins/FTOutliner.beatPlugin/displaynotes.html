<style>

:root {
    --note-bottom: rgba(255, 255, 0, 1);
    --note-border: rgba(70, 70, 0, 1);
    --note-border-light: rgb(191, 191, 2);
}

.alwaysOnTop{
    z-index: 11000 !important;
}

.noteContainer {
    position: absolute !important;
    float: right !important;
    /* height: 1px !important;  */
    margin-bottom: -1px !important;
    width: auto !important;
    pointer-events: none;
    z-index: 9996 !important;
    overflow: visible;

    opacity: 1;

    /*testing new absolute note container*/
    position: absolute !important;
    /* top: 0 !important; */
    right: 2px !important;

    min-height: 15px !important;
    /* height: 100% !important; */

}

.indexcards .level1::after > .noteContainer { 
    /* see outline.css*/
}

.scene:has(.review) .noteContainer{
    right: 10px !important
}

.scene:has(.marker) .noteContainer{
    right: 20px !important
}

.marker {
    background-color: var(--mycolor);
    color: white;

    position: absolute;
    right: -2px;
    top: min(var(--percentage), calc(100% - 12px));

    height: 12px;
    min-width: 20px;
    width: auto; /* to fit marker name */
    max-width: 80%;

    pointer-events: all;

    padding-left: 8px;
    padding-right: 2px;
    
    z-index: 998;
    
    font-weight: bold;
    font-size: 10px;
    line-height: 11px;
    
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;

    border: 1px rgba(0,0,0,0.6) solid;

    clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%, 6px 50%);

    transition: max-width 0.2s;

}

.marker::after{

    content: "";
    position: absolute;
    top: -3.44px;
    left: -2px;

    border-left: 8px rgba(0,0,0,0.6) solid;
    border-top: 8px solid transparent;
    border-bottom: 8px solid transparent;
    border-right: 8px solid transparent;

    height: 1px;
    width: 100%;
    display: block;

}

.marker:hover {

    background-image: linear-gradient(rgba(0,0,0,0.6) 0%,rgba(0,0,0,0.6) 100%) !important;
    opacity: 1;
    color: white !important;
}

#------INDEXCARD STYLES------{}

#flexiContainer.indexcards:not(.allowMarkerTextInAllViews) .marker,
#flexiContainer.nonProportionalMode:not(.allowMarkerTextInAllViews) .marker {
    position: absolute;

    top: 1px !important;
    right: 2px; 
    
    height: 10px;
    width: 15px !important;
    max-width: none !important;
    min-width: 0px !important;
    padding: none;

    transform: rotate(-90deg);

    pointer-events: all !important;

    color: rgba(0,0,0,0) !important;
}

#flexiContainer.indexcards:not(.allowMarkerTextInAllViews) .marker::after,
#flexiContainer.nonProportionalMode:not(.allowMarkerTextInAllViews) .marker::after {

    left: -2px;
    top: -3.44px !important;

    border-top-width: 7px;
    border-bottom-width: 7px;

}

#flexiContainer.indexcards:not(.allowMarkerTextInAllViews) .section>.marker,
#flexiContainer.nonProportionalMode:not(.allowMarkerTextInAllViews) .section>.marker {

    z-index: 9999 !important;
}

#flexiContainer.indexcards:not(.allowMarkerTextInAllViews) :nth-child(2 of .marker),
#flexiContainer.nonProportionalMode:not(.allowMarkerTextInAllViews) :nth-child(2 of .marker){
    right: 14px;
}
#flexiContainer.indexcards:not(.allowMarkerTextInAllViews) :nth-child(3 of .marker),
#flexiContainer.nonProportionalMode:not(.allowMarkerTextInAllViews) :nth-child(3 of .marker){
    right: 26px !important;
}
#flexiContainer.indexcards:not(.allowMarkerTextInAllViews) :nth-child(4 of .marker),
#flexiContainer.nonProportionalMode:not(.allowMarkerTextInAllViews) :nth-child(4 of .marker){
    right: 38px !important;
}
#flexiContainer.indexcards:not(.allowMarkerTextInAllViews) :nth-child(5 of .marker),
#flexiContainer.nonProportionalMode:not(.allowMarkerTextInAllViews) :nth-child(5 of .marker){
    right: 50px !important;
}

#flexiContainer .faux .marker .markertext,
#flexiContainer.unShowMarkerText .marker .markertext,
#flexiContainer.indexcard:not(.allowMarkerTextInAllViews) .marker .markertext,
#flexiContainer.nonProportionalMode:not(.allowMarkerTextInAllViews) .marker .markertext {

    width: 0px;
    opacity: 0;
    text-overflow: clip;
    transition-delay: 0.2s

}

#flexiContainer.unShowMarkerText .marker {

    max-width: 20px
}


#flexiContainer.indexcards:not(.allowMarkerTextInAllViews) .marker:hover,
#flexiContainer.nonProportionalMode:not(.allowMarkerTextInAllViews) .marker:hover {
    transform: translateY(2px) scaleY(1.3) scaleX(0.8) rotate(-90deg) !important;
    transition: 0.1s;
}


.beat{
    position: absolute;

    /* top: calc(var(--percentage) - (var(--percentage) / 100% * 14px)); */
    bottom: max(calc(100% - 14px - var(--percentage)), 0px);

    padding: 0.5px 3px;
    height: 14px; 
    font-size: 10px;
    line-height: 11px;
    font-weight: bold;
    
    background-color: var(--myColor);
    color: white;
    opacity: 1;

    border: 1px rgba(255,255,255,1) solid;
    border-radius: 4px;
    box-shadow: 1px 1px 6px rgba(0,0,0,0.7);

    pointer-events: all !important;
    overflow: visible;

    left: 50%;
    translate: -50% 0; 
    transform-origin: 50% 100%;
}

.largerBeat{
    
    /* height: 20px;
    font-size: 14px;
    line-height: 14px !important;
    margin-top: -3px;

    padding: 1px 4px !important;
    border-width: 2px; */

    transform: scale(1.4);
    
    translate: 0 0; 
    transform-origin: 50% 50%;
    pointer-events: none !important;

    transition: all 0.2s;
    z-index: 99999;

}

.hoveredBeat{

    color: var(--myColor) !important;
    background: white !important;
    border-color: var(--myColor);


}

.hoveredBeat:not(.largerBeat)::after{

    content: "";

    /* background-color: rgba(255,255,255,0.9); */
    border: 10px solid transparent;
    border-left-width: 6px;
    border-right-width: 6px;
    border-top-color: color-mix(in oklab, var(--myColor) 30%, white 70%);

    position: absolute;
    bottom: calc(100% - 2px);
    left: 50%;
    transform: translateX(-50%);
    width: 0px;
    height: 0px;

    /* box-shadow: 1px 2px 3px rgba(0,0,0,0.6),
        inset 0 -1px 0 2px var(--myColor)
        ; */

    /* filter: drop-shadow(1px 4px 3px rgba(0,0,0,0.8)); */

    z-index: 9999;

}
.hoveredBeat:not(.largerBeat)::before{

    content: attr(data-beat-description);
    font-size: 12px;
    line-height: 14px;
    font-weight: normal;
    padding: 8px;
    white-space: normal !important;
    line-break: unset;

    /* width: auto !important; */
    min-width: calc(var(--myWidth) / 2) !important;
    max-width: var(--myWidth) !important;

    position: absolute;
    bottom: calc(100% + 18px);
    left: 50%;
    transform: translateX(-50%);

    /* background-color: rgba(255,255,255,0.9); */
    background-color: color-mix(in oklab, var(--myColor) 30%, white 70%);

    color: black;
    border-radius: 4px;

    transition: all 0.2s;

    z-index: 9998;

    box-shadow: 1px 5px 8px rgba(0,0,0,0.8),
        0 0 0 1px var(--myColor)
        ;
}

.hiddenBeat{
    display: none;
}

/* .largerBeat{

    height: 20px;
    font-size: 14px;
    line-height: 14px !important;
    margin-top: -2px;
    padding: 1px 4px !important;
    border-width: 2px;

} */

.path, .allpaths, .svgForBeats {
    /* stroke-width: 5px;
    stroke-dasharray: 4 2;
    stroke: white !important; */

    pointer-events: none;
    filter: drop-shadow(1px 1px 3px rgba(0,0,0,0.6))
}

.path .bottomstroke{

    stroke-width: 7px;
    stroke: white

}
.path .topstroke{

    stroke-width: 5px;
    stroke: var(--myColor)

}

/* 3D-hack for beats

#flexiContainer.beatsAreDisplayed .scene {
    perspective: 1000px;
    transform-style: flat;
} 

#flexiContainer.beatsAreDisplayed .beat{
  transform-style: preserve-3d;
}

.path{

    transform:translate3d(0, 0, 1px);

} */



/* .pathOf1{
    stroke: purple;
}
.pathOf2{
    stroke: midnightblue;

}
.pathOf3{
    stroke: forestgreen;
}
.pathOf4{
    stroke: firebrick;
}
.pathOf5{
    stroke: deeppink;
}
.pathOf6{
    stroke: black;
}

.hiddenPath{
    display: none;
} */

.sluglineIsHidden > .noteContainer {
    height: 15px !important;
}

.developing-a-new-note {

    opacity: 0.8 !important;

    position: relative !important;
    float: left !important;
    padding: 0 !important;
    margin: 0 0px 0px 2px !important;

    height: 15px !important;
    width: 15px !important;
    border-left: 10px var(--note-bottom) solid; 
    border-top: 15px var(--note-bottom) solid; 
    border-right: 15px transparent solid;

    z-index: 999 !important;
    white-space: normal;
    
    pointer-events: all;

    overflow: hidden;

}

.note {

    opacity: 0.8 !important;

    position: relative !important;
    float: left !important;
    padding: 0 !important;
    margin: 0 0px 0px 2px !important;
    background-color: var(--note-bottom);

    border: 1px solid rgba(0,0,0,0.75);
    height: 15px !important;
    width: 15px !important;
    color: rgba(0,0,0,0);

    z-index: 999 !important;
    white-space: normal;
    
    pointer-events: all;

    overflow: hidden;

    clip-path: polygon(0 0, 100% 0, 100% calc(100% - 4.1px), calc(100% - 4.1px) 100%, 0 100%);
    overflow: hidden;

}

.note {

    top: var(--percentage)

}

.note::before{
    position: absolute;
    border-radius: 0;
    content: " ";
    width: 4px;
    height: 4px;
    border-top: 1px solid  rgba(0,0,0,0.0); /*var(--note-border);*/
    border-left: 1px solid  rgba(0,0,0,0.0); /*var(--note-border);*/
    background: linear-gradient(to bottom right, transparent 0%, transparent 1.5px, rgba(0,0,0,0.7) 1.5px, rgba(0,0,0,0.7) 99%, transparent 100%);
    left: 9px;
    top: 9px;

}

#expandedNote .showSectionPageNumber{
    font-size: 8px !important;
    line-height: 8px !important;
    margin-top: 2px !important;
    padding-right: 10px !important;
}

.selectedNote:not(.review) {
    
    background-image: 

    linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0.7) 100%);
    border-color: black !important; 
}

.selectedNote:not(.review):before {
  border-color: black !important; /* var(--note-border) !important; */
  background: linear-gradient(to bottom right, transparent, transparent 1.5px, black 1.5px, black 2.5px, transparent 2.5px);

}

#expandedNote{

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    font-weight: normal !important;
    text-align: left !important;
    line-height: 12px !important;

    opacity: 1 !important;

    position: absolute;

    min-height: 50px;
    
    background-color: rgb(255,255,128);
    color: rgba(0,0,0,0.7);
    border:1px solid rgba(0,0,0,0.7);
    border-radius: 5px !important;
    
    white-space: normal;
    padding: 0px 8px 8px 8px !important;

    background-image: repeating-linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0) 16px, rgba(0,0,0,0.2) 16px, rgba(0,0,0,0.2) 17px) !important;

    box-shadow: 2px 2px 10px rgba(0,0,0,0.6);
    overflow: hidden;

    z-index: 9997 !important;
}

#expandedNote.omittedNote {

    background-image: 	
        repeating-linear-gradient(
            180deg, 
            rgba(0,0,0,0) 0%, 
            rgba(0,0,0,0) 16px, 
            var(--note-border-light) 16px, 
            var(--note-border-light) 17px),
        repeating-linear-gradient(
			-45deg,
			rgba(0,0,0,0.1) 0px,
			rgba(0,0,0,0.1) 3px,
			rgba(255,255,255,0.2) 3px,
			rgba(255,255,255,0.2) 6px)
            
    !important; 
}

#expandedNote text{
    font-size: 14px !important;
    line-height: 17px !important;
    margin-top: -1px !important; 
    padding-top: 17px;
    padding-bottom: 6px;
    font-family: 'Courier Prime', 'Courier New', Courier, monospace;
    white-space: normal;
    text-decoration: underline dotted var(--note-border);
    display: block;
}

#expandedNote b{
    font-size: 12px !important;
    padding: 5px 9px 0px 9px;
    margin: 0px -9px 2px -9px; 
    line-height: 12px !important;
    background-color: rgba(0,0,0,0.2);
    color:  rgba(0,0,0,0.75);
    display: block;
    text-align: left;

    font-weight: 700;

    overflow: hidden;
    text-overflow: ellipsis;
}

#expandedNote strong{

    font-weight: bold;


}
#expandedNote em,
#expandedNote i{

    font-style: italic !important;

}

.trashNote {
    height: 12px !important;
    width: 12px !important;
    line-height: 12px !important;
    float: right !important;
    overflow: visible !important;
    margin-top: -3px !important;
    pointer-events: all;

}

.trashbutton{
    fill:  rgba(0,0,0,0.75);
    pointer-events: none;
    /* opacity: 0.6 !important; */

}
#trashNote:hover > .trashbutton,
.trashNote:hover{
    fill: rgb(192,0,0) !important;
    opacity: 1 !important;
    
    overflow: visible !important;
    transition: all 0s !important;
    transition-delay: 0ms !important;
}

.notepanelNote > .trashNote {
    
    position: absolute;
    right: 2px;
    top: calc(5px - 2 * var(--fontSizeFactor));

    scale: calc(var(--fontSizeFactor) * 0.8) !important;
    transform-origin: top right;
    
    visibility: hidden;
    transition: all 0s !important;
    transition-delay: all 0s !important;

}

.notpanelNote .trashNote > svg,
.notpanelNote svg
/*, svg.trashbutton */
{
    visibility: hidden;
    transition: all 0s !important;
    transition-delay: all 0s !important;
}

.notepanelNote:hover > .trashNote,
.notepanelNote:hover svg {

    color: white !important;
    fill: white !important;
    visibility: visible;
    z-index: 9999;

    opacity: 1 !important;
    transition: all 0s !important;
    transition-delay: all 0s !important;
    /* outline: 2px solid white */

}

.notepanelNote > .trashNote:hover,
.notepanelNote > .trashNote:hover > svg {

    fill: rgb(255, 64, 64) !important;

}

</style>

<script>

let notesDivStart
let notesDivEnd = "</div>"

function __________NOTES(){}

function collectNotes(wherefrom){

    //TODO: Rename to collectNotesMarkersAndMore
   
    mylog(" from " + JSON.stringify(collectNotes.caller.name)) 
    
    if (!notesAreDisplayed && !markersAreDisplayed && !beatsAreDisplayed && !$("#notepanel.expanded .selectedtab.notetab"))return
    if(!outline || outline.length < 1) return

        let startTime = Date.now()
        let allNotesRaw = []

            let copyOfLines = JSON.parse(JSON.stringify(lines)) //needed because we're going to modify the lines array

            copyOfLines.forEach(line => {

                // if (!["Heading", "Section", "Synopse"].includes(line.typeAsString)){
                    
                    line.notes.forEach(note => {
                        note.range.location += line.range.location
                        let startRedux = 0
                            if(note.type == "marker") { startRedux = 7 }
                            if(note.type == "beat") { startRedux = 5 }
                            if(note.type == "storyline") { startRedux = 10 }

                        let noteText = note.content
                            noteText = noteText.replace(/\/\*(.*)\*\//g, "<span class='omitted'>$1</span>")
                            noteText = noteText.replace(/\*\*\*(.*)\*\*\*/g, "<strong><em>$1</em></strong>")
                            noteText = noteText.replace(/\*\*(.*)\*\*/g, "<strong>$1</strong>")
                            noteText = noteText.replace(/\*(.*)\*/g, "<em>$1</em>")
                            noteText = noteText.replace(/\_(.*)\_/g, "<u>$1</u>")
                            noteText = noteText.replace(/\~(.*)\~/g, "<strike>$1</strike>")
                            noteText = noteText.replace(/\n/g, "<br>")
                            note.formattedContent = note.type == "note" ? noteText : noteText.toUpperCase()

                        //FTOutliner-exclusive color handling: 
                            if(!note.color && note.content.substr(startRedux).match(/^(#*\w+):*/)){
                                let colorValue = note.content.substr(startRedux).match(/^(#*\w+):*/)[1].toLowerCase()
                                if (CSS.supports("color: " + colorValue)) {
                                    note.color = colorValue
                                    startRedux += colorValue.length + 1
                                }
                            }
                            //this is notes-only, so absolute values and not additive
                            if(note.content.startsWith("!")) { note.color = "red"; startRedux = 1}
                            if(note.content.startsWith("!!")) { note.color = "magenta"; startRedux = 2}
                            if(note.content.startsWith("!!!")) { note.color = "#8000FF"; startRedux = 3}
                            if(note.content.startsWith("?")) { note.color = "lime"; startRedux = 1}
                            
                            note.formattedContent = note.formattedContent.substr(startRedux)

                        //#region hack
                        //Beat-specific hacks to fix quirks that may or may not change in the future:
                            //1. hack to fix notes starting at top of line
                                // if(note.range.location !== line.range.location){
                                //     note.range.length ++
                                // }
                            //2. hack to make multiline notes work
                                if(note.content.includes("\n")){
                                    let numberOfExtraLines = 0
                                    while (!copyOfLines[copyOfLines.indexOf(line) + numberOfExtraLines].string.includes("\]\]")){

                                        numberOfExtraLines ++
                                        note.range.length += copyOfLines[copyOfLines.indexOf(line) + numberOfExtraLines].notes[0].range.length + 1 //+1 for the newline character

                                    }
                                }
                        //#endregion

                        if(note.content) allNotesRaw.push(note)
                    })
                //} //this ends the IF that previously excluded headings and sections. Keeping it in in case needed again.
            })
            
            let endTime = Date.now() - startTime

            console.log("all notes", allNotesRaw)

        let allNotes = []
        // let allNotesBeforeStart = allNotesRaw.filter(note => note.range.location < outline[0].sceneStart) || []
        let allMarkers = []
        let allBeats = []

        for (outlineElementNumber = 0; outlineElementNumber < outline.length; outlineElementNumber ++){

            let allEntriesInScene = []
                allEntriesInScene = allNotesRaw.filter(note => note.range.location >= outline[outlineElementNumber].sceneStart && note.range.location < (outline[outlineElementNumber + 1]?.sceneStart || outline[outlineElementNumber].sceneEnd))
            
            //TODO: Perhaps also add beats and/or storyline data category
            let notesInScene = []
                notesInScene =   allEntriesInScene.filter(note => note.type == "note")
            let markersInScene = []
                markersInScene = allEntriesInScene.filter(note => note.type == "marker")
            let beatsInScene = []
                beatsInScene = allEntriesInScene.filter(note => note.type == "beat")

            let headline = "Note in " + ((outline[outlineElementNumber].typeAsString == "Heading") ? "scene " : "section ")
                headline += (outline[outlineElementNumber].typeAsString == "Heading") ? outline[outlineElementNumber].sceneNumber : outline[outlineElementNumber].stringForDisplay

                notesInScene.forEach(note => note.headline = headline)

            allNotes[outlineElementNumber] = notesInScene
            allMarkers[outlineElementNumber] = markersInScene
            allBeats[outlineElementNumber] = beatsInScene
        }

        //allNotes[0] = allNotesBeforeStart.concat(allNotes[0])

        //Done collecting notes and stuff, now send their respective data to the display function && update the notepanel

            globalAllNotes = allNotes //need to call updateNotepanel from outside this function, hence a global notes array

            if(notesAreDisplayed) displayNotes(allNotes, "note")
            if($id("notepanel")?.classList.contains("expanded")) updateNotepanel()

            if(markersAreDisplayed) displayNotes(allMarkers, "marker")
            if(beatsAreDisplayed) displayNotes(allBeats, "beat")

}

function collectReviews(){
        
        if(!documentSetting.reviewsAreDisplayed) return
        
        Beat.callAndWait(() => {
    
            let reviewsObject = Beat.getRawDocumentSetting("Review Ranges")
            return(reviewsObject)
    
        })
        .then(response => { 
    
            reviews = response
            if (reviews.length == 0) return
    
            let reviewNumber = 0
    
            for (element of outline){
    
                if (reviews[reviewNumber]?.range[0] >= element.position) continue
        
                while (reviewNumber < (reviews.length - 0) && reviews[reviewNumber]?.range[0] < element.position){
            
                    reviews[reviewNumber].outlineElementNumber = outline.indexOf(element) - 1
    
                    if(allText.substr(reviews[reviewNumber].range[0] + reviews[reviewNumber].range[1], 1) == "\n"){
                        reviews[reviewNumber].range[1] --
                    }
    
                    reviewNumber ++
    
                }
            }
    
            if (!reviews[reviews.length - 1].outlineElementNumber){
                x = 1
                while (outline[outline.length - x].typeAsString != "Heading") x ++
                reviews[reviews.length - 1].outlineElementNumber = outline.length - x
            }
    
            for (review of reviews){
                review.position = review.range[0]
            }
                    
            displayReviews(reviews)
    
        },error => { 
    
            console.log("Error retrieving reviews") 
    
        })   
}

function displayNotes(allNotes, typeOfNote){

    mylog()

    if(!outline || !allNotes) return

    console.log("%cdisplaying notes", "color: green", allNotes)

    let beatCategories = []
    let existingNotes = document.querySelectorAll(typeOfNote == "note" ? ".noteContainer" : `.${typeOfNote}`)
        existingNotes.forEach(note => note.remove())

    allNotes.forEach(sceneWithNotes => {

        if (sceneWithNotes.length){

            let element = $id(`${allNotes.indexOf(sceneWithNotes)}`) || $(".faux")
                if (element.classList.contains("section") && element.querySelector(":scope > .orphanText")) {
                    element = element.querySelector(":scope > .orphanText")
                }
            let currentContainer

            if (typeOfNote == "note"){

                currentContainer = document.createElement("div")
                currentContainer.id = "noteContainer" + allNotes.indexOf(sceneWithNotes)
                currentContainer.classList = "noteContainer clickThru"
                currentContainer.style.bottom = "15px" // corresponds to the height of a note. TODO: Make this dynamic
                currentContainer.style.height = "calc(100% - 15px)" //previously, this was 15px, but this will center notes at the edge
                if (element.classList.contains("section")) {
                    currentContainer.style.bottom = ""
                    currentContainer.style.top = "0px"
                    currentContainer.style.height = element.querySelector(".section-heading").getBoundingClientRect().height + "px"
                }

                if (element.classList.contains("section")) element.insertBefore(currentContainer, element.querySelector(".section-heading"))
                else element?.appendChild(currentContainer)
            
            }else{

                currentContainer = element

            }

            sceneWithNotes.forEach(note => {
                
                let noteElement = document.createElement("div")
                    noteElement.classList.add(typeOfNote)
                    noteElement.classList.add("collapsed")
                    noteElement.dataset.line = note.range.location
                    noteElement.dataset.length = note.range.length
                    noteElement.dataset.headline = note.headline

                    noteElement.style.backgroundColor = note.color || ""
                    noteElement.style.setProperty("--mycolor", note.color || "red")

                let noteNumber = allNotes.flat().indexOf(note)
                    noteElement.dataset.noteNumber = noteNumber
                    // noteElement.id = "noteNumber" + noteNumber
                    noteElement.id = typeOfNote + "Number" + noteNumber

                if(typeOfNote == "note"){
                    if (userDefault.oldNoteBehavior == true){
                        noteElement.onmouseenter = (event) => {expandNote(false, false, event)}
                        noteElement.onmouseleave = (event) => {collapseNote()}
                    } else {
                        noteElement.onclick = (event) => {expandNote(false, false, event)}
                        noteElement.onmouseenter = (event) => {noteElement.classList.toggle("selectedNote", true)
                                                                $id("notepanelNote" + noteNumber)?.classList.toggle("isSelected", true)}
                        noteElement.onmouseleave = (event) => {noteElement.classList.toggle("selectedNote", false)
                                                                $id("notepanelNote" + noteNumber)?.classList.toggle("isSelected", false)}
                    }
                }

                let percentage = 100 * ((note.range.location - outline[allNotes.indexOf(sceneWithNotes)].sceneStart) / outline[allNotes.indexOf(sceneWithNotes)].range.length) // + "%" // * (element.getBoundingClientRect().height - (15 * currentZoomLevel) - 0)
            
                    noteElement.style.setProperty("--percentage", percentage + "%")
                    noteElement.dataset.content = note.content
                    noteElement.dataset.formattedText = note.formattedContent
                    noteElement.innerHTML = note.formattedContent
                
                    currentContainer.appendChild(noteElement)
                    noteElement.dataset.color = colorsArray.includes(note.color.charAt(0).toUpperCase() + note.color.slice(1)) ? note.color : (rgbToHex(window.getComputedStyle(noteElement).backgroundColor) || "#FFFF00")

                    if(typeOfNote == "marker"){
                        noteElement.style.color = blackOrWhite(window.getComputedStyle(noteElement).backgroundColor)
                        if (currentContainer.classList.contains("section")) noteElement.style.setProperty("--percentage", "2px")
                    }
                    if(typeOfNote == "beat"){

                        //on first occurance of a beat, check all existing categories (storylines)
                        if(beatCategories.length == 0){
                            allNotes.flat().forEach(beat => {
                                let beatCategory = beat.formattedContent.replace(/:.*$/, "").toUpperCase()
                                if(!beatCategories.includes(beatCategory)) beatCategories.push(beatCategory)
                            })
                        }

                        let titleToDisplay = note.formattedContent.replace(/:.*$/, "").toUpperCase()

                        noteElement.style.setProperty("--myColor", storyColors[beatCategories.indexOf(titleToDisplay)] || "black")

                        noteElement.innerHTML = titleToDisplay
                        noteElement.dataset.title = titleToDisplay
                        noteElement.dataset.beatDescription = note.content.replace(/^.*?:/, "").trim()

                        noteElement.onclick = (event) => {
                            $$(`[data-title = "${event.target.dataset.title}"]`).forEach(beat =>{
                                beat.classList.toggle("hoveredBeat", true)
                            })
                        }
                    }
            })
        }
    })
}

function expandNote(tabWasPressed, shiftWasHeld, event){

    mylog()

    if(!$(".note, .review")) return
    if($("#editBox")) return
    exitEdit() //this caused a crash recently, check what this is about 2023-07-19

    let allNoteElements = Array.from($$(".note, .review")) // use for cycling if tab
        allNoteElements.sort((a, b) => { return a.dataset.line - b.dataset.line })

    if(event?.target && !tabWasPressed) {        
        $$(".note.selectedNote").forEach(note => { note.classList.remove("selectedNote") })
        event.target.classList.add("selectedNote")
    }

    if(tabWasPressed){
        let closestNote
        if(!$(".selectedNote")) {
            if($id("youAreHere")) {
                closestNote = allNoteElements.filter(note => Number(note.dataset.line) > Number($id("youAreHere").dataset.location))[0]
            }
        }

        let noteNumberToExpand = closestNote ? allNoteElements.indexOf(closestNote) - !shiftWasHeld : allNoteElements.indexOf($(".selectedNote"))
        if (noteNumberToExpand == -1) { noteNumberToExpand = (shiftWasHeld ? 0 : allNoteElements.length - 1) }
            noteNumberToExpand += (shiftWasHeld ? -1 : 1) 
        if (noteNumberToExpand < 0){ noteNumberToExpand = allNoteElements.length - 1 }
        if(noteNumberToExpand > allNoteElements.length - 1){ noteNumberToExpand = 0 }
            
        noteToExpand = allNoteElements[noteNumberToExpand]
        
        $(".selectedNote")?.classList.remove("selectedNote")
        noteToExpand.classList.add("selectedNote")
    }

    let theNote = $(".note.selectedNote, .review.selectedNote")
        if(!theNote) return
        if(isThisOffScreen(theNote)){
            scrollNicelyIntoView(theNote) 
        }

    $id("expandedNote")?.remove()
    collapseReviews()

    if (theNote.classList.contains("review")) {
        expandReview(theNote)
        return
    }

    //all below is for notes only, reviews are handled elsewhere

    let theExpandedNote = document.createElement("div")
        theExpandedNote.id = "expandedNote"
        theExpandedNote.classList.add("expandedNote")
        theExpandedNote.style.backgroundColor = theNote.dataset.color 
        theExpandedNote.style.backgroundColor = lightenColor(window.getComputedStyle(theNote).backgroundColor, 50)

        theExpandedNote.innerHTML = /*html*/ `<b class='clickThru padRight'>
                                            <div id='placeholder'></div>
                                            ${theNote.dataset.headline}</b>
                                            <text class='clickThru' id='expandedNoteText'>${theNote.dataset.formattedText}</text>`
        theExpandedNote.dataset.line = theNote.dataset.line
        theExpandedNote.dataset.position = theNote.dataset.position
        theExpandedNote.dataset.length = theNote.dataset.length
        theExpandedNote.dataset.color = theNote.dataset.color
        theExpandedNote.style.position = "absolute"
        theExpandedNote.style.top = "50%"
        theExpandedNote.style.left = "50%"

        let expandedWidth = Math.min($(".faux, .section, .scene").getBoundingClientRect().width, window.innerWidth/2)
            theExpandedNote.style.width = expandedWidth + "px"


    flexiContainer.appendChild(theExpandedNote)
    
    //SET POSITION FOR THE EXPANDED NOTE:
        let sizeOfFlexi = $id("flexiContainer").getBoundingClientRect()
        let sizeOfExpandedNote = theExpandedNote.getBoundingClientRect()
        let position = theNote.getBoundingClientRect()

        if (position.top == 0 && position.left == 0) { //this is a note in an omitted scene
            position = theNote.closest(".section").getBoundingClientRect()
            theExpandedNote.classList.add("omittedNote")
        }
        let y = parseInt(JSON.stringify(position.top - sizeOfFlexi.top))
        let x = parseInt(JSON.stringify(position.left - sizeOfFlexi.left))
        let yOrigo = document.getElementById('flexiContainer').scrollTop

        let xPos = Math.min((x + 7.5 - expandedWidth/2), (sizeOfFlexi.width - expandedWidth - 40))
        let yPos = yOrigo + y + 25
            xPos = Math.max(xPos, 20)
            yPos = Math.max(yPos, 20)
        if (xPos + sizeOfExpandedNote.width > sizeOfFlexi.width - 40) {xPos = sizeOfFlexi.width - sizeOfExpandedNote.height - 40}
        if (yPos + sizeOfExpandedNote.height > document.getElementById('flexiContainer').scrollHeight - 40) {yPos = yOrigo + y - 10 - sizeOfExpandedNote.height}

        theExpandedNote.style.top = yPos + "px"
        theExpandedNote.style.left = xPos + "px"

        if (tabWasPressed){
            let trashDiv = document.createElement("div")
                trashDiv.id = "trashNote"
                trashDiv.classList.add("trashNote")
                trashDiv.innerHTML = trashIcon
                trashDiv.onclick = () => {deleteNote()}

            $id("placeholder").replaceWith(trashDiv)
        }
        $id("placeholder")?.remove()

        theExpandedNote.ondblclick = (event) => {
            editContent(event)}

}


function collapseNote(){

mylog(event?.type)

    //remove .isSelected from notePanel, to show hovered note in panel if open
    if($("#notepanel")){
        $id("notepanelNote" + selectedNote)?.classList.remove("isSelected")
        $id("notepanelNote" + selectedNote)?.firstChild.classList.remove("isSelected")
    }

if (event && event.type == "mouseleave" && (document.getElementById('trashNote'))) { //allow hover others when in tab-cycling
    return
}

if (document.getElementById('expandedNote')){
document.getElementById('expandedNote').remove()

let makeRehoverable = document.querySelectorAll('.noHover')
for (i = makeRehoverable.length -1; i > -1; i-- ){
    makeRehoverable[i].classList.remove('noHover')
}

let noteToUnselect = document.querySelector('.selectedNote')
if (noteToUnselect) {noteToUnselect.classList.remove('selectedNote')}
}
}

function deleteNote(){

theClickedThing = event.target

let length = Number(theClickedThing.closest(".expandedNote, .notepanelNote, .note").dataset.length) 
let location = Number(theClickedThing.closest(".expandedNote, .notepanelNote, .note").dataset.line)

goto(location, theClickedThing, length, "#bb8888")

let replaceString = ""
// //condition to find out if a note ends on the final index of a line, if so decrease range by one character so as to leave the linebreak.
//     let currentLine = lines.filter(line => line.range.location <= location + length && line.range.location + line.range.length >= location + length)[0]
//     if (location > currentLine.range.location && location + length == currentLine.range.location + currentLine.range.length){            
//         length --
//     }

setTimeout(() => {
    
    Beat.call((location, length, replaceString)=>{
        Beat.replaceRange(location, length, replaceString)
    }, location, length, replaceString)

}, 1750)

}

function collectReviewsAndThenCreateDoc(){

    alertThis("This feature is currently disabled")

    return

    //here, we should collect reviews if not collected already, then do as much as possible in here before sending to a new doc

}

function createDocFromReviews(reviewsData){

    let newDocumentContents = ">Below is a summary of all REVIEW items in the script<\n\n"
        newDocumentContents += ">**" + (documentSetting.documentName?.toUpperCase() || "UNTITLED") +"**<\n"
    let review = 0

    for (element of outline){

        mylog("in da loop!:" + element.line.string)

        if(review >= reviewsData.length) break

        if (outline.indexOf(element) == reviewsData[review].outlineElementNumber){

            let nearestHeading = element
            let nearestHeadingNumber = outline.indexOf(nearestHeading)
                while(nearestHeading.typeAsString != "Heading" && nearestHeading.typeAsString != "Section" && nearestHeadingNumber > 0){nearestHeading = outline[nearestHeadingNumber - 1]}


            newDocumentContents += `\n**-----------------------------------------------------------**\n`
            newDocumentContents += `\n${nearestHeading.line.string} ${(nearestHeading.sceneNumber ? ("#" + nearestHeading.sceneNumber + "#") : "")}\n\n`
        }

        while (outline[reviewsData[review].outlineElementNumber] == element){

            mylog("in da while" + reviewsData[review].string)

            newDocumentContents += "!_*REVIEW #" + review + "*_\n"
            newDocumentContents += "!*(re: " + entireScreenplay.substr(reviewsData[review].range[0], reviewsData[review].range[1]).trim().replaceAll("\n\n", "\n").replaceAll("\n", "*\n*") + ")*\n\n"
            newDocumentContents += `${reviewsData[review].string.trim()}\n`
            
            review++

            if(review >= reviewsData.length) break

            if(reviewsData[review].outlineElementNumber == reviewsData[review - 1].outlineElementNumber){
                newDocumentContents += `\n>------------------------------<\n\n`
            }

        }

        mylog("DONE")
    }


    Beat.call("Beat.newDocument(`" + newDocumentContents + "`)")

}

function displayReviews(reviewsData){

    if(!outline || !reviewsData) return

    if(!$id("notepanel").classList.contains("expanded") && !documentSetting.reviewsAreDisplayed) return

    //first loop to put parent on each review
    for (review of reviewsData){

        let parent = outline.filter(scene => scene.range.location <= review.range[0] && scene.range.location + scene.range.length >= review.range[0])[0]
            review.outlineElementNumber = outline.indexOf(parent)

    }
        
    globalReviewsData = reviewsData

    $$(".review").forEach(review => review.remove())

    if($id("notepanel").classList.contains("expanded")) updateNotepanel()
    if(!documentSetting.reviewsAreDisplayed) return

    for (review of reviewsData){

        let text = review.string
        let position = review.range[0]
        let element = review.outlineElementNumber
        
        let revdiv = document.createElement("div")
            revdiv.id = "review" + reviewsData.indexOf(review)
            revdiv.classList = "review"
            revdiv.style.position = "absolute"
            revdiv.dataset.line = position
            revdiv.dataset.length = review.range[1]
            revdiv.innerHTML = "âœ“"

            mylog(revdiv.id)
            
        let parentElement = $id(element).closest(".scene, .section")
            if (outline[parentElement.id].typeAsString == "Heading"){
                distance = 100 * (position - outline[parentElement.id].sceneStart) / (outline[parentElement.id].sceneEnd - outline[parentElement.id].sceneStart)
                revdiv.style.top = `calc(${distance}% - 14px)` //the 14px is to align note with speech bubble pointer!
            }else{
                revdiv.style.top = "0%"
            }

        parentElement.appendChild(revdiv)
    }

    mylog("and were done")

}

function highlightReviewInPanel(element){

    if(!element){
        elementsToUnselect = $$(".notepanelReview.isSelected")
        for (el of elementsToUnselect){
            el.classList.remove("isSelected")
        }
        return
    }

    if(!flexiContainer.classList.contains("notepanelIsExpanded"))return

    let elementInPanel = "notepanelR" + element.id.substr(1)
    
    $id(elementInPanel)?.classList.add("isSelected")

}

function createDocFromNotes(){

    if(!globalNotesData)collectNotes()

    let newDocumentContents = ">Below is a summary of all NOTES in the script<\n\n"
        newDocumentContents += ">**" + (documentSetting.documentName?.toUpperCase() || "UNTITLED") +"**<\n"
    let note = 0

    for (element of outline){

        mylog("in da loop!:" + element.line.string)

        if(note >= globalNotesData.length) break

        if (outline.indexOf(element) == globalNotesData[note].outlineElementNumber){

            let nearestHeading = element
            let nearestHeadingNumber = outline.indexOf(nearestHeading)
                while(nearestHeading.typeAsString != "Heading" && nearestHeading.typeAsString != "Section" && nearestHeadingNumber > 0){nearestHeading = outline[nearestHeadingNumber - 1]}

            newDocumentContents += `\n**-----------------------------------------------------------**\n`
            newDocumentContents += `\n${nearestHeading.line.string} ${(nearestHeading.sceneNumber ? ("#" + nearestHeading.sceneNumber + "#") : "")}\n\n`
        }

        while (outline[globalNotesData[note].outlineElementNumber] == element){

            mylog("in da while" + globalNotesData[note].string)

            newDocumentContents += `${globalNotesData[note].string.replace("[[", "").replace("]]", "").replace("<br/>", "\n").replace(/^!+|^\?+/, "").trim()}\n`
            
            note++

            if(note >= globalNotesData.length) break

            if(globalNotesData[note].outlineElementNumber == globalNotesData[note - 1].outlineElementNumber){
                newDocumentContents += `\n>------------------------------<\n\n`
            }

        }

        mylog("DONE")
    }

    Beat.call("Beat.newDocument(`" + newDocumentContents + "`)")

}

function displayBeats(){

    return
   
    if (globalBeatData.length < 1 && !$(".beat")) return
    mylog()

    let currentBeats = $$(".beat")
        for (currentBeat of currentBeats){currentBeat.remove()}
    let currentPaths = $$(".svgForBeats")
        for (currentPath of currentPaths){currentPath.remove()}
    let widthOfColumns = $(".section").getBoundingClientRect().width || $(".sceneheading").getBoundingClientRect().width

    //first lets make one SVG "canvas" the size of the flexiContainer
        let canvasSize = $id("flexiContainer").getBoundingClientRect()
        $id("flexiContainer").innerHTML += "<svg id='theCanvas' class='svgForBeats'></svg>"
        $id("theCanvas").style.position = "absolute"
        $id("theCanvas").style.left = canvasSize.left + "px"
        $id("theCanvas").style.top = canvasSize.top + "px"
        $id("theCanvas").style.width = canvasSize.width + "px"
        $id("theCanvas").style.height = canvasSize.height + "px"

        mylog("there is now an SVG canvas")

    for (let im = 0; im < globalBeatData.length; im++){

        //set element to parent where we will put the beat
        let element = $id(globalBeatData[im].outlineElementNumber) || $(".faux")
        if(!element)return

        theBeatToAddAsCode = "<div id = 'beat" + im + "' class='beat' data-storyline='" + globalBeatData[im].storyline + "' data-line='" + globalBeatData[im].position + "'>" + globalBeatData[im].story + "</div>" 
        element.innerHTML += theBeatToAddAsCode

        theBeatToAdd = $id("beat" +  im)

        theBeatToAdd.style.background = storyColors[globalBeatData[im].storyline - 1]
        theBeatToAdd.style.left = (5 + (globalBeatData[im].storyline - 1) * 15) + "%"
    
        let beatVerticalPosition = -2

        if((outline[globalBeatData[im].outlineElementNumber]?.typeAsString != "Section" 
            ||
            outline[globalBeatData[im].outlineElementNumber]?.numberOfPages > 0)
            && documentSetting.scenesAreProportional){
            beatVerticalPosition = globalBeatData[im].position - outline[globalBeatData[im].outlineElementNumber]?.line.position
            let percentageIntoScene = beatVerticalPosition / outline[globalBeatData[im].outlineElementNumber]?.sceneLength

            if(outline[globalBeatData[im].outlineElementNumber]?.typeAsString == "Section"){
                element = element.querySelector(".orphanText")
            }

            beatVerticalPosition = percentageIntoScene * (Number(element.getBoundingClientRect().height) - 12) //-14 is to fit entire beat inside
        
        }
    
        theBeatToAdd.style.top = beatVerticalPosition + "px"

        mylog("done adding beat #" + im)
    
        //add the connecting lines


        //first let's find the previous beat of this storyline (if present)
        let prev
        for(prev = im - 1; prev > -1; prev --){
            if (globalBeatData[prev].storyline == globalBeatData[im].storyline){
                break
            }
        }
        // now if such previous beat is indeed present, then draw the line
        if (prev > -1){

            mylog(prev + " " + im)
  
            let start = $id("beat" + prev).getBoundingClientRect()
            let end = $id("beat" + im).getBoundingClientRect()

            let theWidth = start.right - start.left 
            let theHeight = start.bottom - start.top
            let midX = start.left + (end.left - start.left)/2 + theWidth/2
            let midY = start.top + (end.top - start.top)/2 + theHeight/2
            
            let xCorrector = widthOfColumns/2
            let yCorrector = 50 //widthOfColumns 
            
            let currentStoryline = globalBeatData[im].storyline
            let thePathID = "path" + im
            let thePathToAdd = `<path class="allpaths hiddenPath pathOf` + currentStoryline + `" id='` + thePathID + `' D='
            M ` + (start.left + theWidth/2) + ` ` + 
                  (start.top + theHeight/2) + `
            C ` + (start.left + theWidth/2 + xCorrector) + ` ` + 
                  (start.top + theHeight/2 + yCorrector) + ` ` + 
                  (end.left + theWidth/2 - xCorrector) + ` ` + (end.top + theHeight/2 - yCorrector) + ` ` + 
                  (end.left + theWidth/2) + ` ` + (end.top + theHeight/2) + 
            ` ' fill = "none"/>`

            $id("theCanvas").innerHTML += thePathToAdd
        }

        //now actually make a duplicate of the last beat, and put it on top!
            let copyOf = theBeatToAdd.cloneNode(true)
            let rect = theBeatToAdd.getBoundingClientRect()
            copyOf.style.position = "absolute"
            copyOf.style.left = rect.left + "px"
            copyOf.style.top = rect.top + "px"
            copyOf.style.opacity = "1"
            copyOf.id = copyOf.id + "(copy)"
            copyOf.borderColor = storyColors[globalBeatData[im].storyline - 1] + " !important"
            copyOf.classList.add("copy", "hiddenBeat")
            copyOf.style.transformOrigin = "center center"
            copyOf.style.translate = "150% 0"
            $("#flexiContainer").appendChild(copyOf)
        
    }
    mylog("exiting")
}

function beatIsHovered(element){

    mylog()

    $$(".path").forEach(path => path.remove())
    $$(".largerBeat").forEach(beat => beat.remove())
    $$(".hoveredBeat").forEach(beat => beat.classList.remove("hoveredBeat"))

    element.classList.add("hoveredBeat")
    let category = element.getAttribute("data-title")
    let allAffectedBeats = Array.from($$(".beat[data-title='" + category + "']"))

    for (let beat of allAffectedBeats){

        beat.style.setProperty("--myWidth", beat.closest(".level1, .faux").getBoundingClientRect().width + "px")
        
        if(beat == allAffectedBeats[0]) continue //skip the first one

        let prevBeat = allAffectedBeats[allAffectedBeats.indexOf(beat) - 1]

        let thisRect = beat.getBoundingClientRect()
        let prevRect = prevBeat.getBoundingClientRect()

        let path = document.createElement("div")
            path.id = "path" + allAffectedBeats.indexOf(beat)
            path.classList.add("path")

            path.style.position = "absolute"
            let pathHeight = thisRect.top - prevRect.top
            let pathWidth = thisRect.left - prevRect.left
            path.style.bottom = "50%"
            path.style.right = "50%"
            path.style.width = Math.abs(pathWidth) + "px"     // 1.1 is to make up for extra bounding box area, to allow margin for overflow
            path.style.height = Math.abs(pathHeight) + "px"   // 1.1 is to make up for extra bounding box area, to allow margin for overflow

            path.innerHTML = /*html*/`<svg height="100%" width="100%" viewBox="0 0 1000 1000" preserveAspectRatio="none" vector-effect="non-scaling-stroke" style="overflow:visible" >
                                    <g>
                                        <path class="bottomstroke" stroke-dasharray="1,6" stroke-linecap="round" fill="none" d="M0,0 C1000,0 0,1000 1000,1000" vector-effect="non-scaling-stroke"/>
                                        <path class="topstroke" stroke-dasharray="1,6" stroke-linecap="round" fill="none" d="M0,0 C1000,0 0,1000 1000,1000" vector-effect="non-scaling-stroke"/>
                                    </g>
                            </svg>`

            if (beat.closest(".level1") == prevBeat.closest(".level1")) {

                pathWidth = beat.closest(".level1")?.getBoundingClientRect().width
                path.style.width = pathWidth + "px"
                path.style.left = (thisRect.width / 2) - (pathWidth / 2) + "px"
                path.innerHTML = /*html*/`<svg height="100%" width="100%" viewBox="0 0 1000 1000" preserveAspectRatio="none" vector-effect="non-scaling-stroke" style="overflow:visible" >
                                <g>
                                    <path class="bottomstroke" stroke-dasharray="1,6" stroke-linecap="round" fill="none" d="M500,0 C1200,0 -200,1000 500,1000" vector-effect="non-scaling-stroke"/>
                                    <path class="topstroke" stroke-dasharray="1,6" stroke-linecap="round" fill="none" d="M500,0 C1200,0 -200,1000 500,1000" vector-effect="non-scaling-stroke"/>
                                </g>
                        </svg>`
            }

            if (pathHeight < 0) {
                path.style.translate = "0 100%"
                path.style.transform = "scaleX(-1)"
                path.style.transformOrigin = "center bottom"
            }

            beat.appendChild(path)

            // now also let's copies of the beats on top!
            // first, if this is the first, then add a clone of the one we skipped
                if(!$(".largerBeat")){
                    cloneTheBeat(prevBeat)
                }
            //then, the rest of them
                cloneTheBeat(beat)

                function cloneTheBeat(beat) {

                    let notepanelWidth = $("#notepanel.expanded")?.getBoundingClientRect().width || 0

                    let copyOf = beat.cloneNode(false)
                    let rect = beat.getBoundingClientRect()
                        copyOf.innerText = beat.innerText
                        copyOf.dataset.title = "" //important, otherwise it will be a duplicate
                        copyOf.style.position = "absolute"
                        copyOf.style.left = rect.left - notepanelWidth + "px"
                        copyOf.style.top = rect.top + "px"
                        copyOf.style.opacity = "1"
                        copyOf.id = copyOf.id + "(copy)"
                        copyOf.classList.add("copy")
                        copyOf.style.pointerEvents = "none"
                        copyOf.style.translate = "0 0"
                        copyOf.style.transformOrigin = "center center"
                    $("#flexiContainer").appendChild(copyOf)
        
                    let redraw = copyOf.getBoundingClientRect()
                        copyOf.classList.add("largerBeat")
                }

    }

    return

    //first make sure the canvas is the same size as the flexiContainer!
    let flexiSize = $id("flexiContainer").getBoundingClientRect()
        $id("theCanvas").style.width = flexiSize.width
        $id("theCanvas").style.left = flexiSize.left

    let theHoveredStoryline = element.getAttribute("data-storyline")
    aBeatIsHovered = true

    let allpaths = $$(".allpaths")
    let thePathsToShow = $$(".pathOf" + theHoveredStoryline)
    let beatsOnTop = $$(".beat.copy")

    for (let path of allpaths){
        path.classList.add("hiddenPath")
    }
    for (let path of thePathsToShow){
        path.classList.remove("hiddenPath")
    }
    for (let beat of beatsOnTop){
        if(beat.getAttribute("data-storyline") == theHoveredStoryline){ 
            beat.classList.remove("hiddenBeat")
            beat.classList.add("largerBeat")
        }else{
            beat.classList.add("hiddenBeat")
            beat.classList.remove("largerBeat")
        }
    }
}

function unhoverAllBeats() {

    $$(".path").forEach(path => path.remove())
    $$(".largerBeat").forEach(beat => beat.remove())
    $$(".hoveredBeat").forEach(beat => beat.classList.remove("hoveredBeat"))

}

function lightenColor(color, percent){
  const validColor = /^#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$|^rgb\(\s*(\d{1,3}\s*,\s*){2}\d{1,3}\s*\)$|^rgba\(\s*(\d{1,3}\s*,\s*){3}(\d?\.?\d+)\s*\)$|^hsl\(\s*\d{1,3}\s*,\s*\d{1,3}%\s*,\s*\d{1,3}%\s*\)$/;
  
  if (!validColor.test(color)) {
    throw new Error('Invalid color format');
  }

  let colorModel = '';
  let colorValues = [];

  if (color.startsWith('#')) {
    const hex = color.replace('#', '');
    if (hex.length === 3) {
      colorModel = 'hex3';
      colorValues = hex.split('').map(c => parseInt(c + c, 16));
    } else if (hex.length === 6) {
      colorModel = 'hex6';
      colorValues = hex.match(/.{2}/g).map(c => parseInt(c, 16));
    }
  } else if (color.startsWith('rgb')) {
    if (color.startsWith('rgba')) {
      colorModel = 'rgba';
      colorValues = color.match(/\d+\.?\d*/g).map(Number);
    } else {
      colorModel = 'rgb';
      colorValues = color.match(/\d+/g).map(Number);
    }
  } else if (color.startsWith('hsl')) {
    colorModel = 'hsl';
    colorValues = color.match(/\d+/g).map(Number);
  }

  const lightenValues = colorValues.map((value, index) => {
    if (colorModel === 'rgba' && index === 3) {
      return Math.min(1, value + (1 - value) * (percent / 100));
    }
    return Math.min(255, value + (255 - value) * (percent / 100));
  });
  
  switch (colorModel) {
    case 'hex3':
      return '#' + lightenValues.map(value => Math.floor(value / 16).toString(16)).join('');
    case 'hex6':
      return '#' + lightenValues.map(value => value.toString(16).padStart(2, '0')).join('');
    case 'rgb':
      return `rgb(${lightenValues.join(', ')})`;
    case 'rgba':
      return `rgba(${lightenValues.slice(0, 3).join(', ')}, ${lightenValues[3]})`;
    case 'hsl':
      return `hsl(${lightenValues[0]}, ${lightenValues[1]}%, ${lightenValues[2]}%)`;
    default:
      throw new Error('Invalid color format');
  }
};

function __________REVIEWS(){}

function expandReview(theClickedThing){

    if(!theClickedThing)return

    collapseReviews()
    
    reviewNumber = theClickedThing?.id.replace("review", "")

    

    expandedReview = $id("review"+reviewNumber)

    theClickedThing.classList.add("expandedReview")
    theClickedThing.classList.add("selectedNote")

    theClickedThing.innerHTML = "<div class='reviewHeadline'>REVIEW #" + reviewNumber + "</div>"
    theClickedThing.innerHTML += globalReviewsData[reviewNumber].string

    $id("notepanelReview" + reviewNumber)?.classList.add("isSelected")

}

function collapseReviews(){

    let expandedReviews = $$(".expandedReview")
    for (expandedReview of expandedReviews){
        expandedReview.classList.remove("expandedReview")
        expandedReview.innerHTML = "âœ“"
    }
    
    $(".notepanelReview.isSelected")?.classList.remove("isSelected")
}

function cycleNotes(shift){

    mylog("cycleNotes")
      
    if(!notesAreDisplayed && !reviewsAreDisplayed){
        toggleDisplayNotes()
        return
    }

    expandNote(true, shift)

    return
    
}

function AlternateWayToCalculateCurve(){

    let currentStoryline = globalBeatData[im].storyline
            let thePathID = "path" + im
            let thePathToAdd = `<path class="allpaths hiddenPath pathOf` + currentStoryline + `" id='` + thePathID + `' D='
            M ` + (start.left + theWidth/2) + ` ` + 
                  (start.top + theHeight/2) + `
            C ` + (start.left + theWidth/2 + xCorrector) + ` ` + 
                  (start.top + theHeight/2 + yCorrector) + ` ` + 
                  (midX) + ` ` + (start.top + theHeight/2 + yCorrector) + ` ` + 
                  (midX) + ` ` + (midY) + `  
            C ` + (midX) + ` `+ (end.top + theHeight/2 - yCorrector) + ` ` + 
                  (end.left + theWidth/2 - xCorrector) + ` ` + (end.top + theHeight/2 - yCorrector) + ` ` + 
                  (end.left + theWidth/2) + ` ` + (end.top + theHeight/2) + 
            ` ' fill = "none"/>`

            $id("theCanvas").innerHTML += thePathToAdd

}

function collectRevisionIndices(){

    if (!documentSetting.showRevisions)return
    mylog()

    Beat.call(`Beat.custom.collectRevisionsInPlugin()`)

}

function paintRevisions(changedAsJSON, reviewAsJSON){

    if(!outline) return

    mylog()

    let changedObject = JSON.parse(changedAsJSON)
    let reviewObject = JSON.parse(reviewAsJSON)

    // let currentDivs = $$(".revision")
    // if(currentDivs.length > 0){
    //     currentDivs.forEach(element => {
    //         element.remove()
    //     });
    // }

    $$(".revision").forEach(element => element.remove())

    for (line of reviewObject.Addition){
        
        // mylog(line)
    
        let changeStart = line[0]
        let changeLength = line[1]
        let changeColor = line[2]

        let outlineNumber

        for (let i = 0; i < outline.length - 1; i++) {
            outlineNumber = -1000
            if (outline[i]?.sceneStart > changeStart) {
                    outlineNumber = i - 1
                    while(outline[outlineNumber]?.typeAsString == "Synopse"){outlineNumber --}
                break}
        }

        if(outlineNumber < -999){
            mylog("no outline")
            outlineNumber = outline.length - 1}

        let revisionDiv = document.createElement("div")
            revisionDiv.id = "revisionAtIndex" + changeStart

        let changeStartPercent = 100 * (changeStart - outline[outlineNumber]?.sceneStart) / (outline[outlineNumber]?.range.length)
        let changeEndPercent = 100 * changeLength / (outline[outlineNumber]?.range.length)

        // now no more reading values, so lets rename outlineNumber
        if(outline[outlineNumber]?.typeAsString == "Section"){
                outlineNumber = "orphanInside" + outlineNumber
            }
            
            revisionDiv.style.position = "absolute"
            revisionDiv.style.top = changeStartPercent + "%"
            revisionDiv.style.height = changeEndPercent + "%"

            revisionDiv.classList.add("revision")
            revisionDiv.classList.add(changeColor)
            revisionDiv.dataset.line = changeStart
            revisionDiv.dataset.length = changeLength

            if($id(outlineNumber))$id(outlineNumber).appendChild(revisionDiv)
    
    }
}


</script>

<style>
    
    .revision{
                
        border-width: .5px;
        border-style: none;
        border-radius: 0.5px;

        /* width: calc(100% + 20px);
        left: -10px; */
        
        width: calc(6px);
        right: -9px;

        /* opacity: 0.8; */

        /* mix-blend-mode: multiply; */

        --background-opacity: 1

    }
    
    .revision.blue{
        background-color: rgba(51, 129, 239, var(--background-opacity));
        border-color: rgba(51, 129, 239, 1);
    }
    .revision.orange{
        background-color: rgba(250, 161, 15, var(--background-opacity));
        border-color: rgba(250, 161, 15, 1)
    }
    .revision.purple{
        background-color: rgba(181, 33, 218, var(--background-opacity));
        border-color: rgba(181, 33, 218, 1)
    }
    .revision.green{
        background-color: rgba(32, 223, 121, var(--background-opacity));
        border-color: rgba(32, 223, 121, 1)
    }

    .revision:hover{
        opacity: 1;
    }

    .review{

        height: 12px;
        width: 18px;
        background-color: #ffe575;
        border: 1px solid hsl(49, 37%, 16%);
        border-radius: 4px;
        color: #7f723a;

        right: -12px; 

        text-align: center;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        font-size: 8px;
        font-weight: bold;
        line-height: 10px;

        z-index: 9996;

        pointer-events: all;
    }

    .review.expandedReview{

        white-space: pre-wrap !important;
        word-wrap: break-word;

        right: 8px;

        height: auto !important;
        width: auto !important;
        max-width: 80% !important;
        min-width: 50% !important;
        padding: 18px 12px 40px 12px; 

        font-size: 11px;
        line-height: 14px;
        font-weight: normal;
        text-align: left;
        color: black;

        border-radius: 10px;
        border-color: #7f723a;

        z-index: 9999;
        box-shadow: 3px 3px 12px rgba(0,0,0,0.4);

        translate: 0 -6px;

    }

    .review > .reviewHeadline{

        position: absolute;
        top: 0;
        left: -1px;
        padding: 0px 12px 0px 12px;
        background-color: #7f723a;
        color: #ffe575;

        border-radius: 10px 10px 0 0 ;

        font-weight: bold;
        font-size: 8px;
        width: calc(100% + 2px);

    }

    .review::after{

        position: absolute;
        bottom: -3px;
        left: 3px;

        content: " ";
        
        border: 4px solid transparent;
        border-top: 0px solid transparent;
        border-left: 4px solid #ffe575;

    }

    .review.expandedReview::after{

        width: 0px;
        height: 0px;

        border-right: 0px;
        border-top: 4px transparent solid;
        border-bottom: 4px transparent solid;
        border-left: 8px solid #ffe575;

        top: 16px;
        left: unset;
        right: -6.44px !important;

    }

    .review::before{

        position: absolute;
        bottom: -5.44px;
        left: 2px;

        content: " ";

        border: 5.44px solid transparent;
        border-top: 0px solid transparent;
        border-left: 5.44px solid hsl(49, 37%, 16%);

    }

    .review.expandedReview::before{

        width: 0px;
        height: 0px;

        border-right: 0px;
        border-top: 5px transparent solid;
        border-bottom: 5px transparent solid;
        border-left: 8px solid #7f723a;

        top: 15px; 
        left: unset;
        right: -8px !important;

    }

    .review:not(.expandedReview).selectedNote,
    .review:hover {

        /* background: hsl(49, 37%, 16%) !important;
        color: #ffe575 !important; */
        border-color: black;

    }

    .review:not(.expandedReview).selectedNote > .reviewHeadline,
    .review:hover > .reviewHeadline {

        background: black;

    }

    .review:hover::before,
    .review:not(.expandedReview).selectedNote::before {
        border-color: transparent !important;
        border-left-color: black !important;
        background: transparent !important;
    }

    .review:hover::after,
    .review:not(.expandedReview).selectedNote::after {
        border-color: transparent !important;
        border-left-color: hsl(49, 37%, 16%) !important;
        background: transparent !important;
    }

</style>
