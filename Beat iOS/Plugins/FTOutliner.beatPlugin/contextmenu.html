<style>

#__________CONTEXTMENU{}

.contextMenu{

    font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    font-size: 0.8rem;
    line-height: 0.8rem;

    --menuBackground: hsla(8, 17%, 91%, 0.8);
    --menuBorder: hsla(0, 0%, 0%, 0.2);
    --menuHover: #4C9AFD;

    background: var(--menuBackground);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);

    padding: 4px 4px;
    width: fit-content;
    border-radius: 6px;
    border: 1px solid var(--menuBorder) ;

    cursor: pointer;

    box-shadow: 2px 2px 15px rgba(0,0,0,0.3);

    z-index: 999999;

}

.contextMenu:focus{

    outline: none;

}

.contextMenu ul {

    padding: 0;
    margin: 0 !important

}

.contextMenu li{

    position: relative;

    display: block;
    padding: 3px 10px 3px 10px !important;
    margin: 0 !important;
    font-size: 13px;
    line-height: 18px !important;
    height: auto;

    list-style-type: none;
    border-radius: 4px;

}

.contextMenu li:not(.greyedOut):hover,
.contextMenu li:not(.greyedOut).keySelected {

    background: var(--menuHover);
    color: white;

}

.contextMenu li.greyedOut{

    opacity: 0.4;

}

.contextMenu hr{

    margin: 6px 8px;
    color: hsla(8, 17%, 91%, 0.6);
    opacity: 0.6;
}

.contextMenu .shortcut {

    float: right;
    padding-left: 20px;
    opacity: 0.3;
    letter-spacing: calc(0.1rem);

}

.contextmenuicon {

    float: left;
    margin-right: 8px;
    height: 14px;
    left: -2px;
    margin-top: 2px !important;
    width: 14px;
    color: hsla(var(--mycolor)) !important;
    fill: hsla(var(--mycolor)) !important;

    overflow: visible !important;

}

.checkedIcon::after {

    content: "✓";

    font-weight: bold;
    font-size: 10px;

    position: absolute;
    width: 100%;
    height: 100%;
    top: 3px;
    left: 12px;
    transform: -50% -50%;

    color: black;
    z-index: 99999;

}

.contextMenu svg{

    transition: none !important;
    fill: hsla(var(--mycolor)) !important;


}

.contextMenu li:not(.greyedOut):hover svg:not(.svgCircle), 
.contextMenu li:not(.greyedOut):hover .contextmenuicon {

        --mycolor: 0, 0%, 100%, 1;
        /* fill: white; */
        
}

</style>

<script>

    let replacableKeys = ["Shift", "Alt", "Meta", "Control", "Tab", "Enter", "Backspace", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "LeftClick"]
    let keystToReplace = ["⇧", "⌥", "⌘", "⌃", "⇥", "↩", "⌫", "↑", "↓", "←", "→", leftClickIcon]
    let svgCircle = "<svg class='svgCircle' viewBox='0 0 100 100'><circle cx='50' cy='50' r='50'/></svg>"
    
    //First create the colors menu
    const availableColors = colorsArray    
    let colorMenuItems = []
        colorsArray.forEach (color => {
            colorMenuItems.push({
                menuItem: color,
                shortcut: [""],
                icon: svgCircle,
                iconColor: color,
                showFor: ["synopsis", "scene", "section"],
                command: (item) => { setItemColor(item, color) },
            })
        })
        colorMenuItems.find(item => item.menuItem === "Remove Color").icon = "<p style ='font-size: 22px !important; transform: translateY(-6px); line-height: 24px !important;'>&#xd7;</p>"
        colorMenuItems.find(item => item.menuItem === "Special").icon = ""
        colorMenuItems.find(item => item.menuItem === "Special").showFor = ["section"]

    //then add all the other menuitems
    let contextMenuContents = colorMenuItems.concat([
        {   
            //NOTE: this entry is a template for the available/used keys in the menu object
            menuItem: "template",
            menuName: function(item) {return "Menu Name"},
            shortcut: ["Meta", "Control", "Alt", "t"],
            icon: svgCircle,
            iconColor: "red",
            iconSpecialColor: function(item) {return "red"},
            hoverColor: "blue",
            showFor: ["nothing"],
            butNotFor: ["omitted"],
            greyOutIf: () => { return !document.querySelector(".selected") }, 
            checkedIf: (item) => { return item.classList.contains("checked") },
            command: (item) => { zoomTo("all", item) },
        },
        {
            menuItem: "divider",
            showFor: ["synopsis", "scene", "section"],
        },
        {   
            menuItem: "Highlight color",
            menuName: function(item) {
                let col = availableColors.find(col => item.classList.contains(col.toLowerCase()))
                if (!col) return "Can't Highlight Custom Colors"
                return this.invisiblyChecked(item) ? `Un-highlight ${col} Scenes`: `Highlight ${col} Scenes`},
            shortcut: ["Alt", "LeftClick"],
            icon: funnelIcon,
            iconColor: "",
            hoverColor: "",
            iconSpecialColor: function(item) {return (this.invisiblyChecked(item)) ? availableColors.find(col => item?.classList?.contains(col.toLowerCase())) : "" }, 
            showFor: ["scene"],
            // butNotFor: ["holiday"],
            invisiblyChecked: (item) => { return (!!document.querySelector("#flexiContainer.uncolorAllScenesBut")) && availableColors.some(col => flexiContainer.classList.contains(col.toLowerCase()) && item.classList.contains(col.toLowerCase())) },
            //checkedIf: (item) => { return (!!document.querySelector("#flexiContainer.uncolorAllScenesBut")) && availableColors.some(col => flexiContainer.classList.contains(col.toLowerCase()) && item.classList.contains(col.toLowerCase())) },
            greyOutIf: (item) => { return !availableColors.find(col => item.classList.contains(col.toLowerCase())) }, 
            command: (item) => { muteColors(item) },
        },
        {   
            menuItem: "Un-highlight all colors",
            // menuName: function(item) {
            //     let col = availableColors.find(col => item.classList.contains(col.toLowerCase()))
            //     if (!col) return "Can Only Highlight Standard Colors"
            //     return this.checkedIf(item) ? `Un-highlight ${col} Scenes`: `Highlight ${col} Scenes`},
            shortcut: ["Alt", "LeftClick"],
            icon: funnelIcon,
            iconColor: "",
            hoverColor: "",
            iconSpecialColor: function(item) {return ((!!document.querySelector("#flexiContainer.uncolorAllScenesBut")) && availableColors.some(col => flexiContainer.classList.contains(col.toLowerCase()) && item.classList.contains(col.toLowerCase()))) ? 
                availableColors.find(col => item.classList.contains(col.toLowerCase())) : "" }, 
            showFor: ["flexiContainer"],
            // butNotFor: ["holiday"],
            //checkedIf: (item) => { return (!!document.querySelector("#flexiContainer.uncolorAllScenesBut")) && availableColors.some(col => flexiContainer.classList.contains(col.toLowerCase()) && item.classList.contains(col.toLowerCase())) },
            greyOutIf: (item) => { return !availableColors.find(col => item.classList.contains(col.toLowerCase())) }, 
            command: (item) => { muteColors(null) },
        },
        {   
            menuItem: "Selection to new Doc",
            shortcut: [""],
            icon: toNewIcon,
            iconColor: "",
            showFor: ["scene"],
            command: (item) => { copyContentsToClipboard() },
        },
        {
            menuItem: "divider",
            showFor: ["scene"],
        },
        //  OMIT AND UN-OMIT ARE CURRENTLY NOT AVAILABLE because wonky
        //  Must be be fixed in order to be used
        // {   
        //     menuItem: "Omit Scene",
        //     shortcut: [""],
        //     icon: hiddenIcon,
        //     iconColor: "",
        //     showFor: ["scene"],
        //     butNotFor: ["isOmitted"],
        //     command: (item) => { omitScene(item) },
        // },
        // {   
        //     menuItem: "Un-omit Scene",
        //     shortcut: [""],
        //     icon: showIcon,
        //     iconColor: "",
        //     showFor: ["isOmitted"],
        //     butNotFor: ["section", "synopsis"],
        //     command: (item) => { unOmitScene(item) },
        // },
        {   
            menuItem: "Rename Scene",
            menuName: (item) => {return "Rename " + (item.classList.contains("scene") ? "Scene" : item.classList.contains("section") ? "Section Header" : item.classList.contains("synopsis") ? "Synopsis" : "")},
            shortcut: ["Alt","Enter"],
            icon: "",
            iconColor: "",
            showFor: ["scene", "section"],
            greyOutIf: (item) => { return $$(".isSelected").length > 1 },
            command: (item) => { editContent(false, $id("youAreHere").closest(".scene, .section")) }, //false is instead of sending an event
        },
        {   
            menuItem: "Delete Scene",
            menuName: (item) => {return "Delete " + (item.classList.contains("scene") ? "Scene" : item.classList.contains("section") ? "Section Header" : item.classList.contains("synopsis") ? "Synopsis" : "")},
            shortcut: ["Meta","Backspace"],
            icon: trashIcon,
            iconColor: "",
            hoverColor: "#880000",
            showFor: ["synopsis", "scene", "section"],
            command: (item) => { deleteScene() }, //send no element, finds selected element in function instead
        },
        {
            menuItem: "divider",
            showFor: ["scene", "section"],
        },
        {   
            menuItem: "Demote Section Level",
            shortcut: ["Control", "Alt", "ArrowRight"],
            icon: "",
            iconColor: "",
            showFor: ["section"],
            // butNotFor: ["level5", "level6", "level7", "level8", "level9"],
            greyOutIf: (item) => { return ["level5", "level6", "level7", "level8", "level9"].includes(item.classList) }, 
            command: (item) => { promoteSection(item) },
        },
        {   
            menuItem: "Promote Section Level",
            shortcut: ["Control", "Alt", "ArrowLeft"],
            icon: "",
            iconColor: "",
            showFor: ["section"],
            // butNotFor: ["level1"],
            greyOutIf: (item) => { return item.classList.contains("level1") }, 
            command: (item) => { demoteSection(item) },
        },
        {
            menuItem: "divider",
            showFor: ["section"],
        },
        {   
            menuItem: "Add Section Before",
            shortcut: ["Control", "Alt", "Shift", "ArrowUp"],
            icon: "",
            iconColor: "",
            showFor: ["scene", "section"],
            greyOutIf: () => { return document.querySelectorAll(".isSelected").length > 1 }, 
            command: (item) => { addElement(item, "section", true) }, //true means beforeInsteadOfAfter
        },
        {   
            menuItem: "Add Section After",
            shortcut: ["Control", "Alt", "Shift", "ArrowDown"],
            icon: "",
            iconColor: "",
            showFor: ["scene", "section"],
            greyOutIf: () => { return document.querySelectorAll(".isSelected").length > 1 },  
            command: (item) => { addElement(item, "section") },
        },
        {
            menuItem: "divider",
            showFor: ["scene", "section"],
        },
        {   
            menuItem: "Add Scene Before",
            shortcut: ["Control", "Alt", "ArrowUp"],
            icon: "",
            iconColor: "",
            showFor: ["scene", "section"],
            greyOutIf: () => { return document.querySelectorAll(".isSelected").length > 1 }, 
            command: (item) => { addElement(item, "scene", true) }, //true means beforeInsteadOfAfter
        },
        {   
            menuItem: "Add Scene After",
            shortcut: ["Control", "Alt", "ArrowDown"],
            icon: "",
            iconColor: "",
            showFor: ["scene", "section"],
            greyOutIf: () => { return document.querySelectorAll(".isSelected").length > 1 },  
            command: (item) => { addElement(item, "scene") },
        },
        // {   
        //     menuItem: "Unlocked scenes to A-scenes",
        //     shortcut: ["!"],
        //     icon: "",
        //     iconColor: "",
        //     showFor: ["flexiContainer"],
        //     greyOutIf: () => { return !outline.find(scene => (/(?:#)(.+)(?:#){1}\s*$/.test(scene.string))) },  
        //     command: (item) => { addLetteredScenesWhenLocked() },
        // },
        //------------------------------SCENE PANEL
        {
            menuItem: "Change THIS occurrence to:",
            menuName: (item) => {let singleText = "THIS occurence "; //default, when not merged lines
                if (Array.from($$(".location")).filter(location => location.textContent == item.textContent).length < 2) singleText = "THIS LONE occurence "; //when only occurence, regardless of merged or not
                if ($id("mergeSimilarLocations").checked && item.closest(".line").querySelectorAll(".duplicateSceneNum").length > 0) singleText = "occurence IN SCENE " + item.closest('.line').querySelector('.sceneNum')?.textContent + " "; //when merged lines and hidden locations on line
                return "Change " + singleText + "to:"},
            spanText: (item) => {
                let hiddenOnLine = item.closest(".line").querySelectorAll(".duplicateSceneNum").length
                return ($id("mergeSimilarLocations").checked && hiddenOnLine > 0) ? hiddenOnLine + " hidden on line will not change" : ""
                },
            nonSelectable: true,
            icon: "",
            iconColor: "",
            showFor: ["similarLocation"],
            butNotFor: ["excludedLocation"],
            // greyOutIf: (item) => { return $id("mergeSimilarLocations").checked && item.closest(".line").querySelectorAll(".duplicateSceneNum").length > 0 },  
            command: (item) => { alertThis("not implemented") },
        },
        {
            menuItem: "replaceSingleLocation",
            showFor: ["special case for similarLocation"],
        },
        {
            menuItem: "New name for THIS occurence...",
            menuName: (item) => {
                if (item.classList.contains("similarLocation") && !item.classList.contains("excludedLocation")) { return "Custom..." }
                let singleText = "THIS occurence of " + item.textContent; //default, when not merged lines
                if (Array.from($$(".location")).filter(location => location.textContent == item.textContent).length < 2) singleText = "THIS LONE occurence"; //when only occurence, regardless of merged or not
                if ($id("mergeSimilarLocations").checked && item.closest(".line").querySelectorAll(".duplicateSceneNum").length > 0) singleText = "occurence IN SCENE " + item.closest('.line').querySelector('.sceneNum')?.textContent + ""; //when merged lines and hidden locations on line
                return "Change " + singleText + " to custom..."},
            spanText: (item) => {                
                let hiddenOnLine = item.closest(".line").querySelectorAll(".duplicateSceneNum").length
                return ($id("mergeSimilarLocations").checked && hiddenOnLine > 0) ? hiddenOnLine + " hidden on line will not change" : ""
                },
            indent: (item) => { return item.classList.contains("similarLocation") && !item.classList.contains("excludedLocation") }, // returns true or false
            whenHovering: (item) => { item.classList.toggle("highlighted", true) },
            whenUnHovering: (item) => { 
                if($id("contextMenu")) {$$(".location.highlighted").forEach(item => item.classList.toggle("highlighted", false)) }
                },
            icon: "",
            iconColor: "",
            showFor: ["location", "similarLocation"],
            // greyOutIf: (item) => { return item.closest(".line").querySelectorAll(".duplicateSceneNum").length > 0 },  
            command: (item) => { newNameDialog(Array.of(item)) },
        },
        {
            menuItem: "divider",
            showFor: ["similarLocation"],
            butNotFor: ["excludedLocation"],
        },
        {
            menuItem: "Change ALL occurrences to:",
            menuName: (item) => {
                return "Change ALL " +
                Array.from($$(".location")).filter(location => location.textContent == item.textContent).length
                + " occurrences to:"
                },
            spanText: (item) => {
                let hiddenItems = Array.from($$(":has(#mergeSimilarLocations:checked):has(#sortDropDown.location)  .hideWhenMergeIsChecked .location")).filter(location => location.textContent == item.textContent)
                return hiddenItems.length ? "including " + hiddenItems.length + " currently hidden)" : ""
                },
            nonSelectable: true,
            icon: "",
            iconColor: "",
            showFor: ["similarLocation"],
            butNotFor: ["excludedLocation"],
            butDontShowIf: (item) => { return Array.from($$(".location")).filter(location => location.textContent == item.textContent).length < 2 },
            command: (item) => { },
            },
        {
            menuItem: "replaceAllLocations",
            showFor: ["special case for similarLocation"],
            },
        {
            menuItem: "New name for all occurences...",
            menuName: (item) => {
                if (item.classList.contains("similarLocation") && !item.classList.contains("excludedLocation")) { return "Custom..." }
                return "Change ALL " +
                Array.from($$(".location")).filter(location => location.textContent == item.textContent).length
                + " occurrences of " + item.textContent + " to custom..."
                },
            spanText: (item) => {
                let hiddenItems = Array.from($$(":has(#mergeSimilarLocations:checked):has(#sortDropDown.location)  .hideWhenMergeIsChecked .location")).filter(location => location.textContent == item.textContent)
                return hiddenItems.length ? "including " + hiddenItems.length + " currently hidden" : ""
                },
            indent: (item) => { return item.classList.contains("similarLocation") && !item.classList.contains("excludedLocation") }, // returns true or false
            whenHovering: (item) => { 
                itemsToColor = Array.from($$(".location")).filter(location => location.textContent == item.textContent) 
                itemsToColor.forEach(item => item.classList.toggle("highlighted", true))
                },
            whenUnHovering: (item) => { 
                if($id("contextMenu")) {$$(".location.highlighted").forEach(item => item.classList.toggle("highlighted", false)) }
                },
            icon: "",
            iconColor: "",
            showFor: ["location", "similarLocation"],
            butDontShowIf: (item) => { return Array.from($$(".location")).filter(location => location.textContent == item.textContent).length < 2 },
            //greyOutIf: () => { return !outline.find(scene => (/(?:#)(.+)(?:#){1}\s*$/.test(scene.string))) },  
            command: (item) => { newNameDialog(Array.from($$(".highlighted"))) },
        },
        // {
        //     menuItem: "divider",
        //     showFor: ["similarLocation"],
        //     butNotFor: ["excludedLocation"],
        //     butDontShowIf: (item) => { return Array.from($$(".location")).filter(location => location.textContent == item.textContent).length < 2 },
            // },
        {
            menuItem: "divider",
            showFor: ["location"],
            butDontShowIf: (item) => { return Array.from($$(".location")).filter(location => location.textContent == item.textContent).length < 2 },
        },
        {
            menuItem: "Exclude this location name from being checked",
            menuName: (item) => {
                return "Exclude " + item.textContent + " from spellcheck"
                },
            // shortcut: ["!"],
            // whenHovering: (item) => { item.classList.toggle("highlighted", true) },
            // whenUnHovering: (item) => { $$(".location.highlighted").forEach(item => item.classList.toggle("highlighted", false)) },
            icon: "",
            iconColor: "",
            showFor: ["similarLocation"],
            butNotFor: ["excludedLocation"],
            // greyOutIf: (item) => { return item.closest(".line").querySelectorAll(".duplicateSceneNum").length > 0 },  
            command: (item) => { 

                if(!documentSetting.excludedLocations) documentSetting.excludedLocations = []
                documentSetting.excludedLocations.push(item.textContent)
                saveCurrentState()
                $$(".location").forEach(element => {if (element.textContent == item.textContent) element.classList.add("excludedLocation")})             
            },
        },
        {
            menuItem: "Remove from excluded location names",
            menuName: (item) => {
                return "Stop excluding " + item.textContent + " from spellcheck"
                },
            // shortcut: ["!"],
            // whenHovering: (item) => { item.classList.toggle("highlighted", true) },
            // whenUnHovering: (item) => { $$(".location.highlighted").forEach(item => item.classList.toggle("highlighted", false)) },
            icon: "",
            iconColor: "",
            showFor: ["excludedLocation"],
            // greyOutIf: (item) => { return item.closest(".line").querySelectorAll(".duplicateSceneNum").length > 0 },  
            command: (item) => { 

                if(!documentSetting.excludedLocations) documentSetting.excludedLocations = []
                documentSetting.excludedLocations.splice(documentSetting.excludedLocations.indexOf(item.textContent), 1)
                saveCurrentState()
                $$(".location").forEach(element => {if (element.textContent == item.textContent) element.classList.remove("excludedLocation")})
            },
        },
        {
            menuItem: "Empty list of locations exluded from spellcheck",
            icon: "",
            iconColor: "",
            showFor: ["location", "line", "scenespanelgroup", "scenespanelcontent"],
            greyOutIf: (item) => { return documentSetting.excludedLocations?.length < 1 },  
            command: (item) => { 

                documentSetting.excludedLocations = []
                saveCurrentState()
                $$(".excludedLocation").forEach(element => element.classList.remove("excludedLocation"))
            },
        },
        {
            menuItem: "divider",
            showFor: ["location"],
        },
        {
            menuItem: "Disregard when sorting",
            menuName: (item) => {
                return "Disregard " + item.textContent + " when sorting/grouping"
                },
            // shortcut: ["!"],
            // whenHovering: (item) => { item.classList.toggle("highlighted", true) },
            // whenUnHovering: (item) => { $$(".location.highlighted").forEach(item => item.classList.toggle("highlighted", false)) },
            icon: "",
            iconColor: "",
            showFor: ["location"],
            butNotFor: ["dontCompare"],
            // greyOutIf: (item) => { return item.closest(".line").querySelectorAll(".duplicateSceneNum").length > 0 },  
            command: (item) => { 

                if(!documentSetting.groupExclusions) documentSetting.groupExclusions = []
                documentSetting.groupExclusions.push(item.textContent)
                saveCurrentState()
                parseSceneHeadings()
            },
        },
        {
            menuItem: "Stop disregarding when sorting",
            menuName: (item) => {
                return "Stop disregarding " + item.textContent + " when sorting/grouping"
                },
            // shortcut: ["!"],
            // whenHovering: (item) => { item.classList.toggle("highlighted", true) },
            // whenUnHovering: (item) => { $$(".location.highlighted").forEach(item => item.classList.toggle("highlighted", false)) },
            icon: "",
            iconColor: "",
            showFor: ["dontCompare"],
            // greyOutIf: (item) => { return item.closest(".line").querySelectorAll(".duplicateSceneNum").length > 0 },  
            command: (item) => { 

                if(!documentSetting.groupExclusions) documentSetting.groupExclusions = []
                documentSetting.groupExclusions.splice(documentSetting.groupExclusions.indexOf(item.textContent), 1)
                saveCurrentState()
                parseSceneHeadings()
            },
        },
        {
            menuItem: "Empty list of locations disregarded when sorting",
            icon: "",
            iconColor: "",
            showFor: ["location", "line", "scenespanelgroup", "scenespanelcontent"],
            greyOutIf: (item) => { return documentSetting.groupExclusions?.length < 1 },  
            command: (item) => { 

                documentSetting.groupExclusions = []
                saveCurrentState()
                parseSceneHeadings()
            },
        },
    //make location into ToD
        {
            menuItem: "divider",
            showFor: ["location"],
            butDontShowIf: (item) => { 
                locationsOnLine = Array.from(item.closest(".line").querySelectorAll(".location:not(.addon)"))
                return !(item == locationsOnLine.at(-1) && item != locationsOnLine.at(0))},        },
        {
            menuItem: "Make this location a Time of Day",
            menuName: (item) => {
                return "Make " + item.textContent + " a Time of Day..."
                },
            icon: "",
            iconColor: "",
            showFor: ["location"],
            butDontShowIf: (item) => { 
                locationsOnLine = Array.from(item.closest(".line").querySelectorAll(".location:not(.addon)"))
                return !(item == locationsOnLine.at(-1) && item != locationsOnLine.at(0))},
            whenHovering: (item) => { 
                itemsToColor = Array.from($$(".location")).filter(location => location.textContent == item.textContent) 
                itemsToColor.forEach(item => item.classList.toggle("highlighted", true))
                },
            whenUnHovering: (item) => { 
                // if($id("contextMenu")) {
                    $$(".location.highlighted").forEach(item => item.classList.toggle("highlighted", false)) 
                // }
            },
            command: (item) => { makeLocationToD(item) },
        },
        //make ToD into Location
        {
            menuItem: "Make this location a Time of Day",
            menuName: (item) => {
                return "Remove " + item.textContent + " from list of Times-of-Day..."
                },
            icon: "",
            iconColor: "",
            showFor: ["timeOfDay"],
            butDontShowIf: (item) => { return item.textContent == "UNKNOWN"},
            whenHovering: (item) => { 
                itemsToColor = Array.from($$(".timeOfDay")).filter(location => location.textContent == item.textContent) 
                itemsToColor.forEach(item => item.classList.toggle("highlighted", true))
                },
            whenUnHovering: (item) => { 
                // if($id("contextMenu")) {
                    $$(".timeOfDay.highlighted").forEach(item => item.classList.toggle("highlighted", false)) 
                // }
            },
            command: (item) => { makeTodLocation(item) },
        },
        // {
        //     menuItem: "divider",
        //     showFor: ["timeOfDay"],
        //     butDontShowIf: (item) => { return item.textContent == "UNKNOWN"},      
        // },
    ])

function __________END_OF_MENU_OBJECT(){}

function newNameDialog(itemArray){

    itemArray.forEach(item => item.classList.add("highlighted"))

    let oldName = itemArray[0].textContent
    let newName = ""

	Beat.callAndWait((oldName, itemArray) => {
        result = Beat.prompt(
            `Location Name Change for ${itemArray.length} scene(s)`,
            `Change the current location name ${oldName} into:`, 
            `${oldName}`
        )    	
        return result
    }, oldName, itemArray)
    .then(
        response => { 
            newName = response
            if (newName == "") return
            if (newName == oldName) return
            if (newName == false) return

            itemArray.forEach(item => item.classList.remove("highlighted"))
            itemArray.sort((a,b) => b.dataset.startIndex - a.dataset.startIndex).forEach(highlighted => swapLocationParts(highlighted.dataset.startIndex, highlighted.dataset.endIndex, `${newName}`))
            return 
        },
        error => { 
            itemArray.forEach(item => item.classList.remove("highlighted"))
            console.log("Error waiting for new name dialog") 
        }
    )
}

function displayContextMenu(event, element){

    event?.preventDefault()
    event?.stopPropagation()
    closeNewMenu()

    element = element || event.target //the element is sent when triggering menu with keys
    let item = element.closest(".synopsis, .scene, .section, .flexiContainer, .location, .timeOfDay, #scenespanelcontent, #scenepanelSettingsButton, #notepanel")
        if (!item) return
        console.log("right clicked " + item.id + ": " + item.classList)

    if (!event?.shiftKey && !event?.metaKey && !item.classList.contains('isSelected')) {deselectAllElements()}
        item.classList.add("isSelected")

    document.querySelectorAll(".contextMenu").forEach( menu => {menu.remove()})
        if (!item) return


    //dynamically add the menu items for similar locations
        contextMenuContents = contextMenuContents.filter(entry => entry.removeAfterUse !== true);
        if (item.classList.contains("similarLocation")){
            let indexToReplace = contextMenuContents.indexOf(contextMenuContents.find(item => item.menuItem == "replaceSingleLocation"))
                contextMenuContents.splice(indexToReplace, 0, ...createReplacementMenuItems(item))
                indexToReplace = contextMenuContents.indexOf(contextMenuContents.find(item => item.menuItem == "replaceAllLocations"))
                contextMenuContents.splice(indexToReplace, 0, ...createReplacementMenuItems(item, true)) //true means all
        }

    let contextMenu = document.createElement("div")
        contextMenu.id = "contextMenu"
        contextMenu.tabIndex = "1"
        contextMenu.classList.add("contextMenu")
        contextMenu.style.position = "absolute"
        let ypos = (event?.clientY || element.getBoundingClientRect().top) + 10
        let xpos = (event?.clientX || element.getBoundingClientRect().left) + 10
        contextMenu.style.top = ypos + "px"
        contextMenu.style.left = xpos + "px"
        contextMenu.onmouseenter = function(){ $$(".keySelected").forEach(item => item.classList.remove("keySelected")) }
        contextMenu.addEventListener("keydown", function(event){
            event.preventDefault()
            event.stopPropagation()
            let items = Array.from(contextMenu.querySelectorAll("li:not(.greyedOut)"))
                if(!items.length) return
            let currentlySelected = items.indexOf(contextMenu.querySelector(".keySelected"))
            if (event.key == "Escape") contextMenu.remove()
            if (event.key == "ArrowDown") {
                    if (currentlySelected === undefined || currentlySelected == items.length -1) currentlySelected = -1
                    items.forEach(item => item.classList.toggle("keySelected", false))
                    items[currentlySelected + 1]?.classList.toggle("keySelected", true)
            }
            if (event.key == "ArrowUp") {
                if (currentlySelected === undefined || currentlySelected == -1) currentlySelected = items.length
                    items.forEach(item => item.classList.toggle("keySelected", false))
                    items[currentlySelected - 1]?.classList.toggle("keySelected", true)
            }
            if (event.key == "Enter") {
                items[currentlySelected]?.click()
                $$(".isSelected").forEach(item => item.classList.remove("isSelected"))
            }
        })
    
    document.body.appendChild(contextMenu)

        contextMenu.focus()
        contextMenu.onblur = function(){ contextMenu.remove() }

    let list = document.createElement("ul")
    for (contentLine of contextMenuContents){

        if (!contentLine.showFor.some(classname => {return item.classList.contains(classname)})) continue
        if (contentLine.butDontShowIf && contentLine.butDontShowIf(item)) continue
        if (contentLine.butNotFor && contentLine.butNotFor.some(classname => {return item.classList.contains(classname)})) continue

        if (contentLine.menuItem == "divider"){
            let listItem = document.createElement("hr")
                list.appendChild(listItem)
                continue
        }

        let shortcutKeysInObj = contentLine.shortcut || ""
        let shortcutKeys = []
            for(shortcutKey of shortcutKeysInObj){
                if (replacableKeys.includes(shortcutKey)){
                    shortcutKey = keystToReplace[replacableKeys.indexOf(shortcutKey)]
                }
            shortcutKeys.push(shortcutKey.toUpperCase())
            }

        let listItem = document.createElement("li")
            if(contentLine.class) listItem.classList.add(contentLine.class) //for special cases
         
        if(contentLine.hoverColor) listItem.style.setProperty("--menuHover", contentLine.hoverColor)
        if(contentLine.greyOutIf) listItem.classList.toggle("greyedOut", contentLine.greyOutIf(item))
        if(contentLine.nonSelectable) listItem.style.pointerEvents = "none"
        if(contentLine.fontWeight) listItem.style.fontWeight = contentLine.fontWeight

        if(contentLine.whenHovering){
            listItem.onmouseenter = (function(command) {
                return function(event) {
                    event.stopImmediatePropagation()
                    event.stopPropagation()
                    event.preventDefault()
                    command(item);
                }
            })(contentLine.whenHovering)
        }
        if(contentLine.whenUnHovering){
            listItem.onmouseleave = (function(command) {
                return function(event) {
                    event.stopImmediatePropagation()
                    event.stopPropagation()
                    event.preventDefault()
                    command(item);
                }
            })(contentLine.whenUnHovering)
        }

        if(!listItem.classList.contains("greyedOut")){
                listItem.onclick = (function(command) {
                return function(event) {
                    event.stopImmediatePropagation()
                    event.stopPropagation()
                    event.preventDefault()
                    command(item);
                    contextMenu.remove()
                }
            })(contentLine.command);
            listItem.oncontextmenu = listItem.onclick
        }

            let iconChecked = false
                if(contentLine.checkedIf && contentLine.checkedIf(item)) iconChecked = true
            
            let iconColor = contentLine.iconColor.toLowerCase()
                if (contentLine.iconSpecialColor) iconColor = contentLine.iconSpecialColor(item).toLowerCase()

                if(availableColors.some(col => contentLine.menuItem.toLowerCase() == col.toLowerCase()) && (item.classList.contains(contentLine.menuItem.toLowerCase()))){
                    iconChecked = true
                }
            let menuName = contentLine.menuItem
                if (contentLine.menuName) menuName = contentLine.menuName(item)
                if (contentLine.spanText) menuName += `<span style='float: right; font-size: 10px; opacity: 0.6; padding-left: 10px;'>${contentLine.spanText(item)}</span>`
            listItem.innerHTML = `<span class='contextmenuicon ${iconChecked ? "checkedIcon" : ""}' style='--mycolor: var(--${iconColor})'>${contentLine.icon || ""}</span>${menuName}<span class='shortcut'>${shortcutKeys.join("")}</span>`;
                if (contentLine.indent && contentLine.indent(item)) listItem.style.borderLeft = "15px solid transparent"

            if (contentLine.iconOutline) listItem.querySelector(".contextmenuicon").style.stroke = contentLine.iconOutline(item)

        list.appendChild(listItem)
    }
    contextMenu.appendChild(list)

    if (xpos + contextMenu.offsetWidth > window.innerWidth) contextMenu.style.left = window.innerWidth - contextMenu.offsetWidth + "px"
    if (ypos + contextMenu.offsetHeight > window.innerHeight) contextMenu.style.top = window.innerHeight - contextMenu.offsetHeight + "px"

    if (list.textContent == "") contextMenu.remove()

}

function setItemColor(item, color){

    toggleWaitState(true)
    $$(".contextMenu").forEach(menu => {menu.remove()})

    if (color.toLowerCase() == "remove color") {color = "none"}

    // if (!item.classList.contains("isSelected") && $$("isSelected").length) {deselectAllElements()} //deselect all other elements if a new one is selected
    if (item && !$$("isSelected").length) {item.classList.add("isSelected")} //select the item if it is not selected yet

    let elements = $$('.isSelected') ||[item]

    for (element of elements) {

        let elementId = element.id

        if (element.classList.contains("synopsis")){
			let parentId = element.closest(".scene, .section").id
			let synopsisNumber = Number(elementId.toString().replace(/^s.*_/, ""))

            Beat.call(([color, parentId, synopsisNumber])=>{
                Beat.setColorForScene(color, Beat.outline()[parentId]?.synopsis[synopsisNumber])
            }, [color, parentId, synopsisNumber])
        
        }else{

            Beat.call((color, elementId)=>{
                Beat.setColorForScene(color, Beat.outline()[elementId])
            }, color, elementId)
        
        } 
    }
}   

function deselectAllElements(){

    mylog()

    $$('.isSelected').forEach(item => item.classList.remove('isSelected'))
    updateSelectionInfo()

}

function createReplacementMenuItems(item, all = false){

    let arrayToReturn = []
    let addedSubstitutes = []
    let substitutes = item.dataset.similarTo.split(",") || []

    let hoverSingle = (item) => { item.classList.toggle("highlighted", true) }
    let hoverAll = (item) => { 
        itemsToColor = Array.from($$(".location")).filter(location => location.textContent == item.textContent) 
        itemsToColor.forEach(item => item.classList.toggle("highlighted", true))
        }

    let hoverString = all ? hoverAll : hoverSingle
    let butDontShowIfString = all ? (item) => { return Array.from($$(".location")).filter(location => location.textContent == item.textContent).length < 2 } : ""
    let greyOutIfString = all ? "" : (item) => { return item.closest(".line").querySelectorAll(".duplicateSceneNum").length > 0 }

    for (let substitute of substitutes){

        if (substitute == "" || addedSubstitutes.includes(substitute)) continue
        addedSubstitutes.push(substitute)

        let replaceSingleLocation = (item) => { swapLocationParts(item.dataset.startIndex, item.dataset.endIndex, `${substitute}`) }
        let replaceAllLocations = (item) => { Array.from($$(".highlighted")).sort((a,b) => b.dataset.startIndex - a.dataset.startIndex).forEach(highlighted => swapLocationParts(highlighted.dataset.startIndex, highlighted.dataset.endIndex, `${substitute}`) )}
        let commandString = all ? replaceAllLocations : replaceSingleLocation

        arrayToReturn.push(
            {
                menuItem: `${substitute}`,
                indent: () => {return true},
                whenHovering: hoverString,
                whenUnHovering: (item) => { $$(".location.highlighted").forEach(item => item.classList.toggle("highlighted", false)) },
                fontWeight: "bold",
                icon: "",
                iconColor: "",
                showFor: ["similarLocation"],
                butNotFor: ["excludedLocation"],
                butDontShowIf: butDontShowIfString,
                // greyOutIf: greyOutIfString,  
                command: commandString,

                removeAfterUse: true,
            }
        )

    }

    return arrayToReturn

}

</script>



<!-- OLD STUFF BELOW -->

<style>
#contextmenu {
    position: absolute;
    /* background-color: rgba(192,192,192,0.9); */
    background-color: rgba(232,232,232,0.9);
    border-radius: 6px;
    font-size: 13px !important; /*was 14*/
    line-height: 16px !important; /*was 20*/
    padding: 6px 10px !important;
    z-index: 99999;
    border: 1px rgb(192, 192, 192) solid;
    box-shadow: 5px 5px 10px rgba(0,0,0,0.3) !important;
    min-width: 200px;

    backdrop-filter: blur(10px) !important;
    -webkit-backdrop-filter: blur(10px) !important;

    
}

#contextmenu .visible {
    display: block;
}

#contextmenu:not(.visible){
    display: none;
}

#contextmenu li {
    color: black;
    list-style-type: none;
    vertical-align: middle !important;
    /* padding-top: 0px !important; */
    padding: 3px 6px 3px 6px !important;
    margin: 0px -6px 0px -6px !important;
}

#contextmenu li:hover {
    background-color: rgb(15,110,212);
    color: white;
    border-radius: 4px !important;
    /* margin-left: -6px !important;
    margin-right: -6px !important;
    padding-left: 6px !important;
    padding-right: 6px !important;
    padding-top: 3px !important; */

    padding: 3px 6px 3px 6px !important;
    margin: 0px -6px 0px -6px !important;
}

#deleteSceneCommand:hover {
    background-color: rgb(128, 0, 0) !important;
    color: white;
    border-radius: 4px !important;
    /* margin-left: -6px !important;
    margin-right: -6px !important;
    padding-left: 6px !important;
    padding-right: 6px !important; */

    padding: 3px 6px 3px 6px !important;
    margin: 0px -6px 0px -6px !important;
}

.colorSquare {
    width: 14px !important; /*was 16*/
    height: 14px !important; /*was 16*/
    border-radius: 50% !important;
    display: inline-block !important;
    padding-top: 4px !important;
    transform: translateY(2.5px);
    overflow: hidden !important;
}

.trashCanMenuItem, .eyeWithCrossMenuItem, .eyeMenuItem, .clipboardMenuItem {
    height: 14px !important;
    width: 14px !important;
    display: inline-block !important;
    transform: translateY(2.5px);
}

.trashCanMenuItem > .trashbutton{
    fill: rgb(165, 0, 0);
    opacity: 0.8 !important;
    transition: fill 0ms !important;
}

.eyeWithCrossMenuItem > .eyeWithCrossIcon,
.eyeMenuItem > .eyeIcon,
.clipboardmenuItem > toNewIcon {
    fill: black;
    opacity: 0.8 !important;
    transition: fill 0ms !important;
}

.trashCanMenuItem:hover > .trashbutton, #deleteSceneCommand:hover > .trashCanMenuItem > .trashbutton, 
.eyeWithCrossMenuItem:hover > .eyeWithCrossIcon, #omitSceneCommand:hover > .eyeWithCrossMenuItem > .eyeWithCrossIcon
.eyeMenuItem:hover > .eyeIcon, #unOmitSceneCommand:hover > .eyeMenuItem > .eyeIcon,
.clipboardMenuItem:hover > #toNewIcon{
    fill: white !important;
    opacity: 1 !important;
    transition: fill 0ms !important;
}

.displayNone{
    display: none !important;
}

.shrinkingWhenOmitting, .shrinkingWhenOmitting > p, div.shrinkingWhenOmitting{
    background: 	repeating-linear-gradient(
			-45deg,
			rgba(0,0,0,0.1) 0px,
			rgba(0,0,0,0.1) 3px,
			rgba(255,255,255,0.05) 3px,
			rgba(255,255,255,0.05) 6px)
			,
	rgba(221, 221, 221, 1) !important;
    height: 0px !important;
    opacity: 0 !important;
    color: rgba(0,0,0,0) !important;
    margin-top: 0px !important;
    margin-bottom: -1px !important;
    
    /* transition: height 0.5s 1s, opacity 0.2s 1.3s, font-color 0.5s 1s, margin 0.5s 1s !important; */
    transition-delay: 2s !important;
    transition: all 1s !important;
}

</style>


<div id="contextmenu" onblur="self.classList.remove('visible')"></div>

<script>

function closeContextMenu(){

    mylog()

    $$(".contextMenu").forEach(menu => {menu.remove()})
    contextMenuIsOpen = false
    
    mylog("exiting")
}

function omitScene(){

    mylog()

    let elements = $$('.isSelected')

        if(documentSetting.scenesAreProportional){
            for(element of elements){
                //element.classList.add("dimmedScene")
                element.classList.add("shrinkingWhenOmitting")
            }
        }

    let elementsToOmit = []
    var sectionfound = false

        for (i = elements.length - 1; i > -1; i--) {
            if ([...elements[i].classList].includes("section")){
                sectionfound = true
                continue
            }
            if (![...elements[i].classList].includes("isOmitted")){
            elementsToOmit.push(elements[i].id)
            }
        }

    if (sectionfound){
        Beat.call(`Beat.alert('Ignoring section(s) when omitting', 'The range you selected to omit contains one or more SECTIONS.\\n\\nSince they already do not print with the script, omitting (essentially: "hiding")\\na section will only add an extra pair of omission marks without any other actual meaning.\\n\\nYou can go ahead and add them manually if you really want to (Beat will not protest) but all your sections will be visible in FTOutliner whether omitted or not.')`)
    }

    actualChangesToScriptInProgress = true //this is for the errorhandler to know what was happening
    Beat.call("Beat.custom.omitScene(" + documentSetting.scenesAreProportional + ", [" + [...elementsToOmit] + "])")
    deselectAllElements()
}

function unOmitScene(){

    mylog()

    // Beat.call("Beat.onTextChangeDisabled = true")
    // Beat.call("Beat.onOutlineChangeDisabled = true")
	// Beat.call("Beat.onSelectionChangeDisabled = true")

    elements = $$('.isSelected')
    let elementsToUnOmit = []

        for (i = elements.length - 1; i > -1; i--) {
            if (elements[i].classList.contains("isOmitted")){
            elementsToUnOmit.push(elements[i].id)
            }
        }

    actualChangesToScriptInProgress = true //this is for the errorhandler to know what was happening
    Beat.call("Beat.custom.unOmitScene([" + [...elementsToUnOmit] + "])")
    deselectAllElements()
}

function deleteScene(){

    //TODO: rewrite this locally!

    mylog()

    elements = $$('.isSelected')
    if (elements.length == 0) return

        for(element of elements){
            element.classList.add("toBeDeleted")
        }

    let elementsToDelete = []

        for (i = elements.length - 1; i > -1; i--) {
            elementsToDelete.push(elements[i].id)
        }
        
    if (elements[0].classList.contains("synopsis")){
        for (e of elementsToDelete) {
            elementsToDelete[elementsToDelete.indexOf(e)] = JSON.stringify(e)
        }
        let doThis = `Beat.custom.deleteSynopsis([${[...elementsToDelete]}], ${userDefault.warningsAreOn})`
        Beat.call(doThis)
    }else if (elements[0].classList.contains("section")){
        Beat.call("Beat.custom.deleteSection([" + [...elementsToDelete] + "], " + userDefault.warningsAreOn + ")")
    }else{
        Beat.call("Beat.custom.deleteScene([" + [...elementsToDelete] + "], " + userDefault.warningsAreOn + ")")
    }
    deselectAllElements()
    mylog("exiting")
}

function ifYesToDelete(){ //this is visually-related stuff only and does not alter any actual data 

    mylog("YES TO DELETE: Now shrinking the scenes.")

    let selectedScenes = document.querySelectorAll('.toBeDeleted')

    mylog("this many: " + selectedScenes.length)

    for (scene of selectedScenes){

        scene.classList.add("longerAnimation")

        let redraw = scene.getBoundingClientRect()

        scene.style.opacity = "1"
        scene.style.height = "0px"
        scene.style.minHeight = "0px"

        let syncons = scene.querySelectorAll(".synopsis, .synopsiscontainer") || false

        if (syncons.length > 0){
            for (syncon of syncons){
            syncon.style.scale = "0px 0px"
            syncon.style.height = "0px"
            syncon.style.minHeight = "0px"
            }
        }
    }    
}

function undimAllScenes(){

    mylog()

    actualChangesToScriptInProgress = false //this is for the errorhandler to know what was happening
    
    $$(".toBeDeleted").forEach(element => {element.classList.remove("toBeDeleted")})
    $$('.dimmedScene').forEach(item => item.classList.remove('dimmedScene'))

}

function copyContentsToClipboard(){

    mylog()

    let selectedElements = $$('.isSelected')

    let ranges = []

    for (let element of selectedElements){
        let obj = {}
        obj.start = outline[element.id].sceneStart 
        obj.end = outline[element.id].sceneEnd
        ranges.push(obj)        
    }
    
    Beat.call("Beat.custom.copyRangeToClipboard('" + JSON.stringify(ranges) + "')")


}

</script>
