/*

Plugin name: FTOutliner
Description: A Flexible Time Outliner for navigating, structuring and editing your screenplay.
Copyright: Fredrik T Olsson 2021-2023
Version: 1.83
Compatibility: 1.996.0
Type: Tool
Image: screenshot.jpg

<Description>
<style>
a {	
	color: #7ca1e6 !important;
	font-weight: bold !important;
}
</style>
<p>A <b>Flexible Time Outliner</b> for navigating, structuring and editing your screenplay.</p>
<ul>
	<li>Arrange your scenes vertically per #act, proportionally to their length in the script</li>
	<li>Show your notes and markers right in their corresponding places in the outline</li>
	<li>Right click to color, delete or rename scenes or sequences</li>
	<li>Drag-and-drop to rearrange scenes or entire sequences</li>
	<li>Track characters by highlighting scenes, or filter by colors</li>
	<li>Export your outline to PDF</li>
	<li>Fully editable index card view</li>
	<li>Slide-over Note Panel all your notes in one long list</li>
	<li>Boneyard (for storing scenes outside of the script structure)
	<li><b>NEW!</b> A pre-flight Scene Manager for checking your sceneheadings for errors and inconsistencies</li>
	<li>and lots more...
</ul>
<p>For more info, questions or support visit <a href="https://github.com/ftolsson/ftoutliner/wiki" target="_blank">the FTOutliner wiki</a></p>
</Description>

*/

function __________VARIABLES(){}

//VERSION NUMBER checking -- also change in the download description above!
var ftoutlinerVersion = "1.83"
Beat.setUserDefault("ftoutlinerVersion", ftoutlinerVersion) 

if (!Beat.iOS() && !Beat.compatibleWith(1.996)) {

	Beat.alert("You need to update Beat to run FTOutliner",
		"This version of FTOutliner uses new features introduced in Beat 1.996 and will not run with older versions.\n\nPlease visit Apple's AppStore to update.")
	return
}

//GLOBAL PLUGIN-ONLY VARIABLES

var windowTitle = "FTOutliner"
let html = buildHTML()

var location, length

var fullUpdateInProgress = false
var selectionTimer = null

var previousLineObject = {} //used to check whether a change is in a line that affects pagination

var viewSubMenuItems = []
var showSubMenuItems = []
var notesSubMenuItems = []
var dialogSubMenuItems = []

let windowSizes = Beat.getDocumentSetting('windowSize')
var thePanelX = windowSizes?.x || 0
var thePanelY = windowSizes?.y || 0
var thePanelWidth = windowSizes?.width || 800
var thePanelHeight = windowSizes?.height || 800

var htmlWindow = Beat.htmlWindow(html, thePanelWidth, thePanelHeight, function(){Beat.end()});
if (!Beat.iOS()) htmlWindow.setFrame(thePanelX, thePanelY, Math.max(thePanelWidth, 380), Math.max(thePanelHeight, 380));

Beat.custom = {}

createMenu(htmlWindow)

if(Beat.getDocumentSetting("ftoutlinerObject")) setWindowTitle()


function __________APP_MENUBAR(){}

function createMenu(htmlWindow) {
	// No menu items on iOS
	if (Beat.iOS()) return;

	viewSubMenuItems.push(Beat.menuItem("Flexible", ["alt", "ctrl", "f"], function () { htmlWindow.runJS("toggleProportional(true)") }))
	viewSubMenuItems.push(Beat.menuItem("Fixed", ["alt", "ctrl", "f"], function () { htmlWindow.runJS("toggleProportional(false)") }))
	viewSubMenuItems.push(Beat.menuItem("Index Cards", ["alt","ctrl", "x"], function () { htmlWindow.runJS("toggleIndexCardMode()") }))

	showSubMenuItems.push(Beat.menuItem("Notes", ["alt", "ctrl", "n"], function () { htmlWindow.runJS("toggleDisplayNotes()") }))
	showSubMenuItems.push(Beat.menuItem("Markers", ["alt", "ctrl", "m"], function () { htmlWindow.runJS("toggleDisplayMarkers()") }))
	showSubMenuItems.push(Beat.menuItem("Reviews", ["alt", "ctrl", "r"], function () { htmlWindow.runJS("toggleDisplayReviews()") }))
	showSubMenuItems.push(Beat.menuItem("Beats", ["alt", "ctrl", "b"], function () { htmlWindow.runJS("toggleDisplayBeats()") }))

	
	notesSubMenuItems.push(Beat.separatorMenuItem())
	notesSubMenuItems.push(Beat.menuItem("Cycle Notes Forward", ["alt", "ctrl", "\t"], function () { htmlWindow.runJS("cycleNotes(false)") }))
	notesSubMenuItems.push(Beat.menuItem("Cycle Notes Backward", ["alt", "ctrl", "shift", "\t"], function () { htmlWindow.runJS("cycleNotes(true)") }))

	let sidePanelMenuItem = Beat.menuItem("Toggle Side Panel", ["alt", "ctrl", "Â§"], function () { htmlWindow.runJS("toggleNotepanel()") })
	let highlightCharacterMenuItem = Beat.menuItem("Highlight Current Character's scenes", ["ctrl", "alt", "c"], function () { highlightCharacter(false, true) })
	dialogSubMenuItems.push(Beat.menuItem("Show Current Character in Dialogue Panel", ["ctrl", "alt", "k"], function () { highlightCharacter(false, false, true) }))
	dialogSubMenuItems.push(Beat.separatorMenuItem())
	dialogSubMenuItems.push(Beat.menuItem("Cycle Dialogue Panel Backward", ["ctrl", "alt", "j"], function () { htmlWindow.runJS("cycleBubbles('-1')") }))
	dialogSubMenuItems.push(Beat.menuItem("Cycle Dialogue Panel Forward", ["ctrl", "alt", "l"], function () { htmlWindow.runJS("cycleBubbles('1')") }))

	let settingsMenuItem = Beat.menuItem("FTOutliner settings", ["alt", "ctrl", ","], function () { htmlWindow.runJS("openSettingsWindow()") })
	//let aboutMenuItem = Beat.menuItem("About FTOutliner", [], function () { htmlWindow.runJS("displayAboutBox()") })
	let splitScreenMenuItem = Beat.menuItem("Arrange side-by-side with Beat", ["alt", "ctrl", "\ "], function () { htmlWindow.runJS("setSharedScreen()") })
	let switchFocusMenuItem = Beat.menuItem("Switch focus Beat â®‚ FTOutliner", ["alt", "ctrl", "cmd", "\ "], function () { htmlWindow.runJS("switchFocus()") })
	let zoomInMenuItem = Beat.menuItem("Increase Font Size", ["alt", "ctrl", "+"], function () { htmlWindow.runJS("zoomSizes('+')") })
	let zoomOutMenuItem = Beat.menuItem("Decrease Font Size", ["alt", "ctrl", "-"], function () { htmlWindow.runJS("zoomSizes('-')") })
	let resetZoomMenuItem = Beat.menuItem("Reset Font Size", ["alt", "ctrl", "0"], function () { htmlWindow.runJS("zoomSizes('0')") })

	let viewSubMenu = Beat.submenu("Views", viewSubMenuItems)
	let showSubMenu = Beat.submenu("Show", showSubMenuItems)
	let notesSubMenu = Beat.submenu("Notes", notesSubMenuItems)
	let dialogSubMenu = Beat.submenu("Dialogue", dialogSubMenuItems)
	let menuDivider1 = Beat.separatorMenuItem()
	let menuDivider2 = Beat.separatorMenuItem()
	let menuDivider3 = Beat.separatorMenuItem()
	let menuDivider4 = Beat.separatorMenuItem()
	let appMenu = Beat.menu("FTOutliner", [
		// aboutMenuItem,
		settingsMenuItem,
		menuDivider1,
		zoomInMenuItem, 
		zoomOutMenuItem,
		resetZoomMenuItem,
		menuDivider2,
		viewSubMenu, 
		showSubMenu, 
		notesSubMenu, 
		dialogSubMenu,
		menuDivider3,
		sidePanelMenuItem,
		highlightCharacterMenuItem,
		menuDivider4,
		splitScreenMenuItem, 
		switchFocusMenuItem,
	])

}

Beat.custom.switchToHTML = function(){
	htmlWindow.focus()
}

Beat.custom.updateShowMenu = function(itemNumber, value){
	if (!Beat.iOS()) updateShowMenuItem(itemNumber, value)
}
Beat.custom.updateViewsMenu = function(itemNumber, value) {
	if (!Beat.iOS()) updateViewsMenuItem(itemNumber, value)
}

function updateShowMenuItem(itemNumber, value){
	showSubMenuItems[itemNumber].on = value
}
function updateViewsMenuItem(itemNumber, value){
	viewSubMenuItems[itemNumber].on = value
}

function __________EXTERNAL_WINDOW_STUFF(){}

var secondWindow

Beat.custom.displaySecondWindow = function(name, file, width=800, height=800, selfClose=true, data=false) {
	// No second window on iOS (for now)
	if (Beat.iOS()) return;
	
	//if (secondWindow) secondWindow.close()
	secondWindow = false
	secondWindow = Beat.htmlWindow("", width, height, function(){}, true);

	let secondHTML = Beat.assetAsString(file)
	selfCloseString = selfClose ? `
		window.addEventListener("blur", function (){
			if (typeof temporarilyDisableClose !== 'undefined' && temporarilyDisableClose == true) {
				temporarilyDisableClose = false
				return
			}
			Beat.call("Beat.custom.closeSecondWindow()")
		})` : ``

	secondWindow.setHTML(`
		<body>${secondHTML}
			<script>
				${selfCloseString}
				var pageData = ${data}
			</script>
		</body>
	`)
	
	let x = (Beat.screen()[2] - width)/2
	let y = (Beat.screen()[3] - height)/2
	secondWindow.setFrame(x, y, width, height)
	secondWindow.title = name

}

Beat.custom.closeSecondWindow = function(){	secondWindow.close() }

Beat.custom.sendToMain = function(key, value, nameOfVariable){

	// //Turn this on to see what got sent over
	// 	let contents = ""
	// 		for ([key, value] of Object.entries(objectValues)){
	// 			contents += ((value == true) ? "âœ… " : "âŒ ") + key + " ----- " + value + "\n"
	// 		}
	// 		Beat.alert(`contents of sent variable ${nameOfVariable}:`, contents) 
	Beat.log(typeof value)
	Beat.log("ðŸ’œ" + "," + key + "," + value + "," + nameOfVariable)
	
	if (["object", "array", "string"].includes(typeof value)) value = JSON.stringify(value)

	htmlWindow.runJS(`	console.log("start of sendToMain")
						${nameOfVariable}.${key} = ${value};
			
						console.log("${nameOfVariable}" + ", " + "${key}")
						console.log(JSON.stringify(${nameOfVariable}.${key}))

						applySettings()
						saveCurrentState()
					`)

}

Beat.custom.reApplySettings = function(){ 
	
	htmlWindow.runJS("applySettings()") 

}

function __________RELOADERS(){}

Beat.custom.reloadCode = function(){ //hard restart the plugin, i.e. the entire code

	Beat.restart()

}

Beat.custom.reloadHTML = function(){ //soft restart the plugin, i.e. only the HTML window

	html = buildHTML()
	
	let windowSizes = Beat.getDocumentSetting('windowSize')
		thePanelX = windowSizes?.x || 0
		thePanelY = windowSizes?.y || 0
		thePanelWidth = windowSizes?.width || 800
		thePanelHeight = windowSizes?.height || 800

	htmlWindow.setHTML(html)
	htmlWindow.setFrame(thePanelX, thePanelY, Math.max(thePanelWidth, 380), thePanelHeight) 
}

function buildHTML(){

	let reset = 		Beat.assetAsString("reset.css")
	let css = 			Beat.assetAsString("outline.css")
	let globals = 		Beat.assetAsString("globals.html")
	let template = 		Beat.assetAsString("outline.html")
	let dnd = 			Beat.assetAsString("drag-and-drop.html")
	let dialogs = 		Beat.assetAsString("dialogs.html")
	let charactertracking = Beat.assetAsString("charactertracking.html")
	let displaynotes = 	Beat.assetAsString("displaynotes.html")
	let contextmenu = 	Beat.assetAsString("contextmenu.html")
	let keyboard = 		Beat.assetAsString("keyboard.html")
	let editcontent = 	Beat.assetAsString("editcontent.html")
	let addelements = 	Beat.assetAsString("addelements.html")
	let printCSS = 		Beat.assetAsString("printOutlineCSS.css")
	let indexcards = 	Beat.assetAsString("indexCards.html")
	let indexcards_css = Beat.assetAsString("indexCards.css")
	let notepanel = 	Beat.assetAsString("notepanel.html")
	let scenepanel = 	Beat.assetAsString("scenepanel.html")
	let menu = 			Beat.assetAsString("menu.html")
	let printing = 		Beat.assetAsString("printing.html")

	let html = 
		reset +
		css +
		globals +
		charactertracking +
		displaynotes +
		contextmenu + 
		keyboard +
		indexcards +
		indexcards_css +
		notepanel +
		scenepanel +
		menu +
		dialogs + 
		printing +
		editcontent +
		addelements +
		dnd +
		template

	return html

}

Beat.onEscape(function () {

	htmlWindow.runJS("escapeWasPressed()")

})

function __________OUTLINE_UPDATERS(){}

/* === NOTE ON HOW UPDATING WORKS AS OF TODAY, 2023-07-28 ===

1. onTextChange is called. If it determines that pagination is not needed, it adds the old pagination to the new data and sends it.
2a. If so, it also invalidates the next onPreviewFinished
2b. If not invalidated, onPreviewFinished creates pagination and sends with the data
That's basically it. Plus a lot of ifs and buts. But who counts.
*/

var pauseOnePaginationUpdate = false
var paginationPauseTimer = null
var onTextChangeTimer = null

var emergencyExit = false

Beat.onTextChange(function(location, length) { 

	console.log("onTextChange")

	// This function checks every change for whether it affects layout.
	// If it does not, we skip pagination which is time consuming. 

	// If there is no previousLineObject, no need to wait, just do a full update. UNCLEAR IF THIS EVER HAPPENS, though.
	if (!previousLineObject || previousLineObject.length == 0) {
		Beat.log("NO PREVIOUS LINE OBJECT, so immediately doing full update")
		fullUpdateInProgress = true
		Beat.custom.updateEntireOutline()
		return
	}
	
	emergencyExit = true

	if(fullUpdateInProgress){ 
		//this is now set when deferring to onPreviewFinished, so that a paginated update can never be canceled 
		//by re-evaluating the need while already waiting for one
		return
	}
	
	if (onTextChangeTimer) {
        onTextChangeTimer.invalidate()
        onTextChangeTimer = null
    }

	pauseOnePaginationUpdate = false //used to come after the timer. Putting it here should exclude the possibility that a change that needs pagination is overruled by one that doesn't.

	htmlWindow.runJS(`toggleWaitState(true)`)
    onTextChangeTimer = Beat.timer(0.2, function() {
		
		//determine which line changed
			let parser = Beat.currentParser
			let line = parser.lineAtPosition(location)
				if(!line) return //try to circumvent error when typing on last line

			// First guard clause: If several lines changed (e.g. copy/paste) make full update
			if((previousLineObject.length != Beat.lines().length)){
				console.log("Sending to previewFinished b/c multiple lines changed")
				fullUpdateInProgress = true
				return 
			} 
			// Second guard clause: If the number of omitted lines or headings changed, go to full update
			if ((previousLineObject.filter(line => ["Heading", "Section"].includes(line.typeAsString)).map(line => line.typeAsString).join(",") != Beat.outline().map(line => line.typeAsString()).join(","))
				||
				(previousLineObject.filter(line => line.omitted).length != Beat.lines().filter(line => line.omitted).length)
				|| 
				(previousLineObject.filter(line => line.typeAsString === "Heading").map(line => line.UUID).join(",") !== Beat.outline().filter(line => line.typeAsString() === "Heading").map(line => line.UUID).join(","))
				){
				console.log("Deferring to previewFinished b/c number/order of outline objects, or some sceneheading UUID, changed")
				fullUpdateInProgress = true
				return
			}

		//determine the printing part of the line that has changed
			let nonPrintingRanges = line.ranges.notes//.concat(line.ranges.omitted)
			let	nonPrintingRangesRev = nonPrintingRanges.sort((a, b) => b[0] - a[0]);
			let printingLine = nonPrintingRangesRev.reduce((acc, [location, length]) => acc.slice(0, location) + acc.slice(location + length), line.string);

		//determine the printing part of the previous, same line
			let linePreviously = previousLineObject[Beat.lines().indexOf(line)] || false
			let previousNonPrintingRanges = linePreviously?.ranges?.notes//.concat(linePreviously.ranges.omitted)
			let previousNonPrintingRangesRev = previousNonPrintingRanges?.sort((a, b) => b[0] - a[0]);
			let previousPrintingLine = previousNonPrintingRangesRev?.reduce((acc, [location, length]) => acc.slice(0, location) + acc.slice(location + length), linePreviously.string);

		// Third guard clause: if NOT in an non-printing object, and the printing part of the line did chang, go to full update

			if(!["Section", "Note", "Synopse"].includes(line.typeAsString()) 
				&&
				!line.omitted
				&&
				printingLine.trimEnd() !== previousPrintingLine?.trimEnd()
				){

					console.log ("deferring to onPreviewFinished")
					fullUpdateInProgress = true

					htmlWindow.runJS(`toggleWaitState(true)`)
					return
			}

		//WE ARE PAST THE GUARD CLAUSES! Let's do a pagination-less update

				console.log ("determining only pagination-less update needed")
				pauseOnePaginationUpdate = true

				try{

					Beat.custom.updateEntireOutline(location, length, true) //true means skip pagination

				}catch(e){ //because if error while updating we need a new, full round

					console.log("error in onTextChange: " + e)
					console.log("Therefore a last-minute deferral to onPreviewFinished")
					
					pauseOnePaginationUpdate = false
					fullUpdateInProgress = true
					return

				}

	}) //timer end

})

Beat.onPreviewFinished(function(changedIndices) {

	if(pauseOnePaginationUpdate){
		pauseOnePaginationUpdate = false
		return
	}
    
	// This is the earliest index which has changed
	// currently not used, but might be used in the future to optimize the update
    let index = changedIndices[0]

	// this triggers the "updateEntireOutline", which WILL deliver pagination data
	// NOTE: currently, "updateEntireOutline" is a custom Beat function in order to being callable from the HTML window
	//Beat.custom.updateEntireOutline()

	try{

		Beat.custom.updateEntireOutline() //no parameters means DO pagination

	}catch(e){ //because if error while updating we need a new, full round

		console.log("An error happened updating outline WITH pagination: " + e)
		console.log("Therefore scheduling a new round")
		
		pauseOnePaginationUpdate = false
		fullUpdateInProgress = true
		return

	}
})

Beat.custom.updateEntireOutline = function (location, length, skipPagination = false) {

	console.time("updateEntireOutline")
	Beat.log("updateEntireOutline called with skipPagination = " + skipPagination)
	Beat.log("...")
	fullUpdateInProgress = true
	emergencyExit = false

	Beat.log("... 2")
	htmlWindow.runJS(`toggleWaitState(true)`);
	Beat.log("... 3")
	
	if (!location) {
		location = Beat.selectedRange().location
	}

	let outline = Beat.outline()
	let linesAsJSON = Beat.linesAsJSON()
	let fullScreenplay = Beat.getText()

	Beat.async(function () {
		
		let json
			// Get the whole JSON, paginated or not
			if (skipPagination) {
				Beat.log("Skipping pagination")
				json = JSON.stringify(outlineWithoutPagination(outline))
			} else {
				Beat.log("Doing pagination")
				json = JSON.stringify(outlineWithPagination(outline))
			}

			// moved these outside of async 2024-01-22
				// Get all lines as JSON
				// let linesAsJSON = Beat.linesAsJSON()
				// Send it to the HTML window
				// let fullScreenplay = Beat.getText()

			// will this finally catch incorrectly delivered pagination?
			// CHECK #1. ERROR because mismatch in number of lines
			if (JSON.parse(linesAsJSON).length != Beat.lines().length || JSON.parse(json).length != Beat.outline().length){			
				//fullUpdateInProgress = false //why? if error happens, better to make big update next time?
				pauseOnePaginationUpdate = false
				Beat.sync(function () {
					Beat.resetPreview()
				})
				return
			}
			// CHECK #2. ERROR because no data
			if((!json || !linesAsJSON) && fullScreenplay.length > 0){
				//fullUpdateInProgress = false //why? if error happens, better to make big update next time?
				pauseOnePaginationUpdate = false
				Beat.sync(function () {
					Beat.resetPreview()
				})
				return
			}

			// ALL GOOD: Send the data to the HTML window
			Beat.sync(function () {
				
				//BUG HUNT PART III: If zero-height scenes encountred, don't update outline but immediately reset preview
				if (json.endsWith(`"alert"]`)) {
					pauseOnePaginationUpdate = false
					fullUpdateInProgress = false
					Beat.resetPreview()
					return
				}

				console.log("SENDING JSON. Skipping pagination: ", skipPagination)

				let novelmode = Beat.getRawDocumentSetting("Stylesheet") == "Novel"
				htmlWindow.runJS(`updateEntireOutline(${json}, ${location}, ${length}, ${fullScreenplay.length}, ${linesAsJSON}, ${novelmode}, ${JSON.stringify(fullScreenplay)})`)
			})
			
			previousLineObject = JSON.parse(linesAsJSON)

			fullUpdateInProgress = false	
	})
	console.timeEnd("updateEntireOutline")
}

let sceneData = [] //This is now global in order to be re-useable when no new pagination is needed
let pagination
const paginationManager = Beat.currentPagination()

function outlineWithoutPagination(outlineCopy) {

	// This name is a bit misleading: The data returned does contain pagination -- but it is the old one.
	// So "without" refers to no pagination being performed, just copied from last round.

	console.log("outlineWithoutPagination")	

	let altSceneData = []
	// const outlineCopy = Beat.outline()

	try{
		for (const scene of outlineCopy) {
			let data = scene.json()
	
			let previousData = sceneData[outlineCopy.indexOf(scene)]
	
				data.numberOfPages = previousData.numberOfPages
				data.startsOnPage = previousData.startsOnPage
				data.positionOnPage = previousData.positionOnPage
				data.breakLines = previousData.breakLines
		
			altSceneData.push(data)
		}
	}catch{

		return false

	}

	return altSceneData

}

function outlineWithPagination(outlineCopy) {

	console.log("outlineWithPagination")
	
	let zeroHeight = []
		pagination = paginationManager.finishedPagination
		sceneData = []
	//const outlineCopy = Beat.outline()
	const parser = Beat.currentParser
	let boneyardStartsAtIndex = parser?.boneyardAct?.position

	let inBoneyard = false
	let maxPageHeight = Beat.currentPagination().maxPageHeight
	let myHeight
	
	for (const scene of outlineCopy) {

		if(emergencyExit) break

		if(scene.position > boneyardStartsAtIndex)	inBoneyard = true

		let data = scene.json()
		
		if (inBoneyard) {

			let myPagination = Beat.pagination() //starts a new pagination for this scene only
			let linesToPaginate = Beat.linesForScene(scene)
				myPagination.paginateLines(linesToPaginate)
			 	
				data.numberOfPages = myPagination.heightForScene(scene) 
				//the rest of the values have no meaning for objects in boneyard so setting them to zero
					data.lineHeight = 0
					data.startsOnPage = 0
					data.positionOnPage = 0.0
					data.breakLines = []
					sceneData.push(data)

				continue
		}

		try{
			data.numberOfPages = pagination.heightForRange({ location: scene.position, length: scene.length }) / Beat.currentPagination().maxPageHeight
			//the above replaces the below, because of faulty values in heightForScene. This may or may not have been fixed in Beat already.
			//data.numberOfPages = pagination.heightForScene(scene) / Beat.currentPagination().maxPageHeight
			data.lineHeight = pagination.heightForRange({ location: scene.position, length: scene.line.length}) / Beat.currentPagination().maxPageHeight
		}catch{
			//this try/catch is here because of a bug in Beat that sometimes claims pagination.heightForRange is undefined
			Beat.sync(function () {
				Beat.alert("An error has occured.", "The pagination has returned a faulty value, and FTOutliner cannot continue.\n\nWhen you hit ENTER, FTOutliner will try again. If the error persists, please try to restart FTOutliner. Also, please report the incident to the developer.")
				Beat.resetPreview()
			})
		}

		data.startsOnPage = pagination.pageNumberAt(scene.position)
		data.positionOnPage = 0.0

		//BUG HUNT PART I: Checking for zero-height scenes!
			if (data.numberOfPages == 0 && data.typeAsString == "Heading" && !data.omitted && !inBoneyard){ 
				zeroHeight.push(data)
			}

		if (data.startsOnPage > 0) {
			// Get the (relative) y position of the block for this line
			// If it's below 0, it's probably an outline element
			let page = pagination.pages[data.startsOnPage - 1]
				data.positionOnPage = page?.positionOfBlockForLine(scene.line)

				//hack to find the positionOnPage for a section with length, since its inherent positionOnPage is -1 due to not being printed
					if(sceneData.length > 0 && scene.typeAsString() == "Section" && data.numberOfPages > 0){
						let closestPrecedingScene = -1
						while (sceneData.at(closestPrecedingScene).numberOfPages <= 0 && (sceneData.length + closestPrecedingScene > 0)){
							closestPrecedingScene --
						}
						data.positionOnPage = sceneData.at(closestPrecedingScene)?.positionOnPage + sceneData[outlineCopy.indexOf(scene) - 1]?.numberOfPages
						console.log("Section with length! This is its positionOnPage: ", data.positionOnPage)
					} 

				if (data.positionOnPage < 0) data.positionOnPage = 0.0;
		} 

		//any length of a hidden heading should go into its closest visible parent!
			if (data.omitted){			
				let closestVisibleParent = -1
					while (sceneData.at(closestVisibleParent).omitted && (sceneData.length + closestVisibleParent > 0)){
						closestVisibleParent --
					}
					sceneData.at(closestVisibleParent).numberOfPages += data.numberOfPages
				data.numberOfPages = 0 //because the height of the omitted scene is now transferred to previous unomitted one
			}

		let lines = Beat.linesForScene(scene)
		let breakLines
		
			breakLines = lines.filter(line => line.typeAsString() == "Page Break").map(line => {
				let previousLine = Beat.currentParser.lineAtIndex(line.range.location - 2)
				let thispage = pagination.pageNumberAt(line.range.location - 2)
				let page = pagination.pages[thispage -1]
				return {"startPageIncFraction": thispage + page?.positionOfBlockForLine(previousLine), "fullpage": pagination.pageNumberAt(line.range.location), "pageBreakIndex": line.range.location}
			})
		
		data.breakLines = breakLines
		sceneData.push(data)

	}
	
	//BUG HUNT PART II: Firing a dialog if there was a zero-height scene
		if (zeroHeight.length){ 
			console.log("!!! Zero Height Happened for " + zeroHeight.length + "scenes:", zeroHeight)
			sceneData.push("alert") 
			Beat.sync(function () {
					// 	Beat.resetPreview()
					//	Beat.alert("Zero Height Scene(s) Detected", "FTOutliner has detected one or more scenes with zero height. This is a bug in Beat, and you should report it to the developer. In the meantime, FTOutliner will try to fix it for you. Please wait a few seconds.")
				})
		}

	return sceneData
}

function __________SELECTION_CHANGE_UPDATERS(){}

Beat.onSelectionChange(function (location, length) {

	console.log("onSelectionChange")

	htmlWindow.runJS(`currentCaretPosition = ${location}; currentCaretLength = ${length}`);
	
	//Does this one ever happen now? Answer: the full update does, the small does not.
	if (fullUpdateInProgress){
		return
	}

    if (selectionTimer) {
        selectionTimer.invalidate()
        selectionTimer = null
    }

    selectionTimer = Beat.timer(0.2, function() {
		htmlWindow.runJS("youAreHere(" + location + "," + length + ", true)") 
		//the TRUE at the end means this was a "positionChangeOnly"
    })
})

function __________HELPERS_____(){}

// function numberOfWrappedLines(str, typeAsString) {

// 	console.time("calculating number of wrapped lines")

// 	const pageWidths = {
// 		Action: 60,
// 		Character: 38,
// 		Parenthetical: 27,
// 		Dialogue: 35,
// 		Lyrics: 60,
// 		Heading: 60,
// 	}

// 	const pageWidth = pageWidths[typeAsString]

// 	let words = str.split(' ');
// 	let lineLength = 0;
// 	let lineCount = 1;
  
// 	for (let word of words) {
// 	  if (lineLength + word.length <= pageWidth) {
// 		lineLength += word.length + 1; // add 1 for the space
// 	  } else {
// 		lineCount++;
// 		lineLength = word.length + 1; // add 1 for the space
// 	  }
// 	}
  
// 	console.timeEnd("calculating number of wrapped lines")
// 	return lineCount;
//   }

function titleCaseThis(str) {
	let upper = true;
	let newStr = "";
	for (let i = 0, l = str.length; i < l; i++) {
	  if (str[i] == " " || str[i] == "-") {
		upper = true;
		  newStr += str[i];
		continue;
	  }
	  newStr += upper ? str[i].toUpperCase() : str[i].toLowerCase();
	  upper = false;
	}
	return newStr;
}


function ____________________STORING_STUFF___________________(){}

Beat.custom.saveWindowSize = function() { //DO NOT REMOVE THIS, IT IS CALLED FROM THE HTML WINDOW
	
	let winSize = htmlWindow.getFrame()
	
	Beat.setDocumentSetting('windowSize', {

		x: winSize.x,
		y: winSize.y,
		width: winSize.width,
		height: winSize.height

	})
}

function ____________________NOTES__________(){}

Beat.custom.testSendingLineObject = function(){

	console.time("lineobject")

	const allLines = Array.from(Beat.lines())

	console.timeEnd("lineobject")

}

function ____________________OMITTING_AND_DELETING__________(){}

Beat.custom.omitScene = function(scenesAreProportional, scenesToOmit, updatesDisabled) { 

	if (scenesAreProportional == 1){
		let plural = (scenesToOmit.length > 1) ? "s" : ""
		Beat.alert("Where did my scene"+plural+" go?", "You are now in Flexible mode, and since omitted scenes literally takes up no space in the finished script, they are invisible in this view.\n\nToggle to non-flexible display (shortcut\xa0F) to see any omitted scenes." )
	}

	const outline = [...Beat.outline()]

	// Beat.onTextChangeDisabled = true
	// Beat.onOutlineChangeDisabled = true
	// Beat.onSelectionChangeDisabled = true

	for (let i=0; i<scenesToOmit.length; i++){

		nextScene = 1
		while (outline[scenesToOmit[i]+nextScene] && outline[scenesToOmit[i]+nextScene].typeAsString() == "Synopse") {
			nextScene ++
		}

		//first: check for any omissions INSIDE the scene we want to omit!
		let omissionInsideScene = false
		if (outline[scenesToOmit[i]]?.omitted == 0){
			let loopToThisPoint = outline[scenesToOmit[i] + nextScene]?.line.position - 1 || Beat.getText().length - 1
			let lineLooper = outline[scenesToOmit[i]].line.position
			let parser = Beat.currentParser
			while (lineLooper < loopToThisPoint){
				lineLooper += parser.lineAtPosition(lineLooper)?.string.length + 1
				if(parser.lineAtPosition(lineLooper)?.string.includes("*/")){
					omissionInsideScene = true
				}
			}	
		}
		if (omissionInsideScene){
			let headline = "Conflicting omission inside\n" 
			headline += (scenesToOmit.length > 1) ? "": "the scene\n" + outline[scenesToOmit[i]].sceneNumber + ". "
			headline += outline[scenesToOmit[i]].line.stripFormatting().toUpperCase() 
			headline += (scenesToOmit.length > 1) ? "\n(currently scene #" + outline[scenesToOmit[i]].sceneNumber + ")":""
			let message = (scenesToOmit.length > 1) ? "One of the scenes": "The scene"  
			message += " you are trying to omit already has an omitted/hidden chunk of text inside it.\n\nDue to how Fountain works, omitting the scene would only work up to the point where that chunk ends.\n\nThis scene is therefore left UN-OMITTED."
			if (scenesToOmit.length > 1){message += "\n\nNOTE: FTOutliner will continue to try with the rest of your selected scenes.\nYou will be notified for every scene where this problem occurs."}
			Beat.alert(headline, message)
			continue
		}

		//Beat.log("for number " + i + " ...which is " + scenesToOmit[i])
		//Beat.log("...outline[scenesToOmit[i]] is " + JSON.stringify(outline[scenesToOmit[i]]))
		//try{
		if (!outline[scenesToOmit[i] + nextScene]){
			Beat.addString("*/\n\n", (Beat.getText().length))
		}else if (!outline[scenesToOmit[i] + nextScene].omitted){
			Beat.addString("*/\n\n", (outline[scenesToOmit[i]].position + outline[scenesToOmit[i]].length))
		}
	
	//}catch{
	//	Beat.alert("this was it", "scenesToOmit[i] == " + scenesToOmit[i] + "\n but outline[scenesToOmit[i]] = " + JSON.stringify(outline[scenesToOmit[i]]))
	//}

		if (outline[scenesToOmit[i] + nextScene] && outline[scenesToOmit[i] + nextScene].omitted){
			let parser = Beat.currentParser
			let startMarkerFound = false
			let position = (outline[scenesToOmit[i] + nextScene].line.position - 1)

			while (position > outline[scenesToOmit[i]]?.position && !startMarkerFound){
				position = parser.lineAtPosition(position).position //puts us at front of line
				
				if (parser.lineAtPosition(position).string.includes("/*")){
					a = parser.lineAtPosition(position).string.replace("/*", "*/\n/*")
					Beat.replaceRange(position, a.length - 3, a)
					startMarkerFound = true
				}
				position--
			}
			if(!startMarkerFound){Beat.alert('Error finding starting point of omitted scene', 'Failed to locate any /* marker BELOW \n\n' + outline[scenesToOmit[i]].sceneNumber + ". " + outline[scenesToOmit[i]].string.toUpperCase() + "\n\nPlease check manually if your script looks as expected, or hit cmd+z for UNDO to return to the state before your latest action.")}

		}

		if (!outline[scenesToOmit[i]-1] || !outline[scenesToOmit[i]-1].omitted){Beat.addString("/*\n\n", outline[scenesToOmit[i]].position)}

		if(outline[scenesToOmit[i]-1] && outline[scenesToOmit[i]-1].omitted){
			let parser = Beat.currentParser
			let endMarkerFound = false
			let position = (outline[scenesToOmit[i]].line.position - 1)
			
			while (position > outline[scenesToOmit[i]-1].position && !endMarkerFound){
				position = parser.lineAtPosition(position).position //puts us at front of line
				
				if (parser.lineAtPosition(position).string.includes("*/")){
					a = parser.lineAtPosition(position).string.replace("*/", "*/\n/*")
					Beat.replaceRange(position, a.length - 3, a)
					startMarkerFound = true
				}
				position--
			}
			if(!startMarkerFound){Beat.alert('Error finding end point of omitted scene', 'Failed to locate any */ marker ABOVE \n\n' + outline[scenesToOmit[i]].sceneNumber + ". " + outline[scenesToOmit[i]].string.toUpperCase() + "\n\nPlease check manually if your script looks as expected, or hit cmd+z for UNDO to return to the state before your latest action.")}
		}

		startCheck = outline[scenesToOmit[i]]?.position || fullLength
		if (outline[scenesToOmit[i] + nextScene]){
			endCheck = outline[scenesToOmit[i] + nextScene].position
			checkForDoubleBlankLines(endCheck)
		}
		checkForDoubleBlankLines(startCheck)
	}
}

Beat.custom.unOmitScene = function(scenesToUnOmit, updatesDisabled) {

	const outline = [...Beat.outline()]

	for (let i = 0; i < scenesToUnOmit.length; i++){

		nextScene = 1
		while (outline[scenesToUnOmit[i]+nextScene] && outline[scenesToUnOmit[i]+nextScene].typeAsString() == "Synopse") {
			nextScene ++
		}

		let omittedScene = scenesToUnOmit[i]
			if(!outline[omittedScene]?.omitted){
				continue}

		let parser = Beat.currentParser
		const position = outline[omittedScene].line.position
		let endMarkerFound = false
		let startMarkerFound = false

		//step ONE: remove the end of the omission if appropriate (or start a new one!)
		//=============================================================================

		let endOfScenePosition = (outline[omittedScene + nextScene]) ? 
			outline[omittedScene + nextScene].line.position - 1 :
			Beat.getText().length	
		endOfScenePosition = parser.lineAtPosition(endOfScenePosition).position // turn last index of line into first index of line instead

		let jumpBack = 0

		//case one: look for closing omission point from next scenes start to this
		while (endOfScenePosition - jumpBack > position && !endMarkerFound){
			
			let line = parser.lineAtPosition(endOfScenePosition - jumpBack).string

			if (line.includes('*/')){

				lineToInsert = line.replace('*/','')
				startOfLine = parser.lineAtPosition(endOfScenePosition - jumpBack).position
				lengthOfLine = parser.lineAtPosition(endOfScenePosition - jumpBack).length
					// if (lineToInsert == '') {
					// lengthOfLine ++}
	
				Beat.replaceRange(startOfLine, lengthOfLine, lineToInsert)
				checkForDoubleBlankLines(startOfLine)
				endMarkerFound = true
			}

			jumpBack = jumpBack + line.length + 1
		}
	
		//case two: no closing point found, but next scene omitted too
		if (!endMarkerFound && outline[omittedScene + nextScene] && outline[omittedScene + nextScene].omitted == 1){
			Beat.addString("/*\n\n", endOfScenePosition + 1)
			checkForDoubleBlankLines(endOfScenePosition + 1)
			endMarkerFound = true
		}

		//step TWO: remove start of omission -- case one: look for starting point up until start of prev scene
		//====================================================================================================

		let line = parser.lineAtPosition(position).string
		jumpBack = 0

		while (!line.includes('/*')){

			jumpBack++
			let lengthOfThatLine = parser.lineAtPosition(position - jumpBack).length
			jumpBack = jumpBack + lengthOfThatLine

			line = parser.lineAtPosition(position - jumpBack).string

			if (position - jumpBack < 0 || position - jumpBack <= outline[omittedScene - 1].line.position || line.includes('*/')){
				break
			}
		}

		if (line.includes('/*')){
			lineToInsert = line.replace('/*','')
			let startOfLine = parser.lineAtPosition(position - jumpBack).position
			let lengthOfLine = parser.lineAtPosition(position - jumpBack).length
				if (lineToInsert == '') {
				lengthOfLine ++}

			Beat.replaceRange(startOfLine, lengthOfLine, lineToInsert)
			checkForDoubleBlankLines(startOfLine)
			startMarkerFound = true

		}else{ 
			
			// case two: No start encountered. Is the previous scene omitted? Then just end omission before this one
			if (outline[omittedScene - 1].omitted == 1){
				Beat.addString("*/\n\n", position)
				checkForDoubleBlankLines(position)
				startMarkerFound = true
			}
		}

		//now a double-check: is no error given but the scene still omitted? Then add end marker before scene. 
		if (startMarkerFound && endMarkerFound && outline[omittedScene]?.omitted == 1){
			Beat.addString("*/\n",outline[omittedScene].line.position)
		}
	
		if (!startMarkerFound || !endMarkerFound){
			let whatsMissing = (!startMarkerFound && !endMarkerFound) ? "neither " : ""
			whatsMissing += "the "
			whatsMissing += (!startMarkerFound) ? "start " : ""
			whatsMissing += (!startMarkerFound && !endMarkerFound) ? "nor the " : ""
			whatsMissing += (!endMarkerFound) ? "end " : ""
			whatsMissing += "point"
			whatsMissing += (!startMarkerFound && !endMarkerFound) ? "s " : " "
			Beat.alert("Failed to un-omit scene" + outline[omittedScene].sceneNumber, "FTOutliner could not find\n" + whatsMissing + "\nwhen trying to un-omit the scene\n" + outline[omittedScene].string.toUpperCase() + ".\n\nPlease check your script manually to remove the corresponding /* and */ entries.\n\nSorry for the inconvenience, this really shouldn't happen.")
		}
		
	} // ENDING THE LOOP
}

Beat.custom.deleteSynopsis = function(elementsToDelete, warningsAreOn) {

	const outline = [...Beat.outline()]
	let deleteMessage

	if(elementsToDelete[0].includes("_")){
		let parentNumber = Number(elementsToDelete.at(-1).toString().replace(/^s/, "").replace(/_.*$/, ""))
		let synopsisNumber = Number(elementsToDelete.at(-1).toString().replace(/^s.*_/, ""))
		deleteMessage = Beat.outline()[parentNumber].synopsis[synopsisNumber].string.toUpperCase().replace(/^=/, "").replace(/\[\[.*\]\]/, "")
	}else{
		deleteMessage = outline[elementsToDelete.at(-1)].string.toUpperCase().replace(/^=/, "").replace(/\[\[.*\]\]/, "")
	}
	if (elementsToDelete.length > 1) {deleteMessage += "\nand " + (elementsToDelete.length - 1) + " more synopsis"}

	if(warningsAreOn){
		
		let doDelete = Beat.modal({
			title: "Confirm Delete",
			info: "You are about to delete the synopsis\n" + deleteMessage + "\nNo other script text will be deleted\n\nThe action CAN be undone by hitting cmd+z.",
			items: [
				{
					type: "checkbox",
					name: "turnOffWarnings",
					label: "Turn off all warnings in the future"
				},
			]
		}, response => {
			
			if (response) {
				// The user clicked OK
				doDelete = true
				if (response.turnOffWarnings == true) {
					Beat.custom.sendToMain("warningsAreOn", false, "userDefault")
				}
				return true
			} else {
				// The user clicked CANCEL
				return false
			}
		})
	
		if (!doDelete){
			htmlWindow.runJS(`
				undimAllScenes()
				`)
			return
		}
	}

	for (element of elementsToDelete){
		if (element.includes("_")){
			let parentNumber = Number(element.toString().replace(/^s/, "").replace(/_.*$/, ""))
			let synopsisNumber = Number(element.toString().replace(/^s.*_/, ""))
			let synopsis = Beat.outline()[parentNumber].synopsis[synopsisNumber]

			let where = Math.abs(synopsis.position)
			let howLong = synopsis.string.length
			
			Beat.replaceRange(where, howLong, "")
			checkForDoubleBlankLines(where + 1)
			
		}else{
			
			let where = Math.abs(outline[element].position)
			let howLong = outline[element].line.string.length

			Beat.replaceRange(where, howLong, "")
			checkForDoubleBlankLines(where + 1)
		}
	}
}

Beat.custom.deleteScene = function(elementsToDelete, warningsAreOn) {

	Beat.log("deleteScene()")

	const outline = [...Beat.outline()]

	Beat.log('you have sent:' + elementsToDelete + 'elements to delete')

	let deleteMessage = outline[elementsToDelete.at(-1)].string.toUpperCase().replace(/^=/, "").replace(/\[\[.*\]\]/, "")
	for (let i = 2; i < Math.min(6, elementsToDelete.length); i++){
		deleteMessage += "\n" + outline[elementsToDelete.at(-i)].string.toUpperCase().replace(/^=/, "").replace(/\[\[.*\]\]/, "")
	}
	if (elementsToDelete.length > 5) {deleteMessage += "\nand " + (elementsToDelete.length - 5) + " more"}

	if(warningsAreOn){

		let doDelete = Beat.modal({
			title: "Confirm Delete",
			info: "You are about to delete the scene" + (elementsToDelete.length > 1 ? "s" : "") + "\n" + deleteMessage + "\nincluding all contents.\n\nThis can be undone by hitting cmd+z.",
			items: [
				{
					type: "checkbox",
					name: "turnOffWarnings",
					label: "Turn off all warnings in the future"
				},
			]
		}, response => {
			
			if (response) {
				// The user clicked OK
				doDelete = true
				if (response.turnOffWarnings == true) {
					Beat.custom.sendToMain("warningsAreOn", false, "userDefault")
				}
				return true
			} else {
				// The user clicked CANCEL
				return false
			}
		})
	
		if (!doDelete){
			htmlWindow.runJS(`
				undimAllScenes()
				`)
			return
		}
	}

	//first: un-omit all scenes to delete + the one after.
	this.unOmitScene(elementsToDelete, true)

		for (let j=0; j<elementsToDelete.length; j++){

			//here check for synopsis
			let nextScene = 1
			let endPosition = false
			while (outline[elementsToDelete[j] + nextScene + 1] && outline[elementsToDelete[j] + nextScene].typeAsString() == "Synopse") {
				
				Beat.log("evaluating that there is a next scene. It contains this: " + outline[elementsToDelete[j] + nextScene + 1])
				
				nextScene ++
			}

			//unomit next scene to avoid removing /* marker
			let nextSceneIsOmitted = false
			if(outline[elementsToDelete[j] + nextScene]?.length > 0 && outline[elementsToDelete[j] + nextScene]?.omitted == true){
				
				Beat.custom.unOmitScene([elementsToDelete[j] + nextScene], true)			
				nextSceneIsOmitted = true
			}

			// NOTE: i in omit-function kills i here! Changed to j

			endPosition = outline[elementsToDelete[j] + nextScene] ? (outline[elementsToDelete[j] + nextScene].position) : Beat.getText().length //moved out from "check for synopsis" loop because un-omitting may change value of position
			let theLength = Math.max((endPosition - outline[elementsToDelete[j]].position), outline[elementsToDelete[j]].length)
			
			Beat.replaceRange(outline[elementsToDelete[j]].position, theLength, "")
		
			if(nextSceneIsOmitted){
				Beat.custom.omitScene(false, [elementsToDelete[j]], true) // and NOT nextScene, because one scene is now removed!
				nextSceneIsOmitted = false
			}
		}

		htmlWindow.runJS("ifYesToDelete()")

}

Beat.custom.resetPreview = function(){

	Beat.resetPreview()

}

Beat.custom.deleteSection = function(elementsToDelete, warningsAreOn) {

	Beat.log("deleteSection()")

	const outline = [...Beat.outline()]

	Beat.log('you have sent:' + elementsToDelete + 'elements to delete')

	let deleteMessage = outline[elementsToDelete[elementsToDelete.length-1]].string.toUpperCase().replace(/^=/, "").replace(/\[\[.*\]\]/, "")
	if (elementsToDelete.length > 1) {deleteMessage += "\nand " + (elementsToDelete.length - 1) + " more sequences"}

	if(warningsAreOn){
		
		let doDelete = Beat.modal({
			title: "Confirm Delete",
			info: "You are about to delete the section\n" + deleteMessage + "\nincluding any potential synopsis directly inside it.\n\nScenes and nested sections inside/below will stay intact.\n\nThis action can be undone by hitting cmd+z.",
			items: [
				{
					type: "checkbox",
					name: "turnOffWarnings",
					label: "Turn off all warnings in the future"
				},
			]
		}, response => {
			
			if (response) {
				// The user clicked OK
				doDelete = true
				if (response.turnOffWarnings == true) {
					Beat.custom.sendToMain("warningsAreOn", false, "userDefault")
				}
				return true
			} else {
				// The user clicked CANCEL
				return false
			}
		})
	
		if (!doDelete){
			htmlWindow.runJS(`
				undimAllScenes()
				`)
			return
		}
	}

	// Beat.onTextChangeDisabled = true
	// Beat.onOutlineChangeDisabled = true
	// Beat.onSelectionChangeDisabled = true

	// PREVIOSLY CHECKED FOR OMISSIONS (inherited from deleteScene() function)
	// but since we're only removing a LINE now, let's just check that there is no /* or */ present in the line
	// and if there is, add it back

		// //first: un-omit all scenes to delete + the one after.
		// this.unOmitScene(elementsToDelete, true)

		for (let j=0; j<elementsToDelete.length; j++){

			//here check for synopsis
			let nextScene = 1
			let endPosition = false
			// while (outline[elementsToDelete[j] + nextScene + 1] && outline[elementsToDelete[j] + nextScene].typeAsString() == "Synopse") {
			// 	nextScene ++
			// }

			// //unomit next scene to avoid removing /* marker
			// let nextSceneIsOmitted = false
			// if(outline[elementsToDelete[j] + nextScene] && outline[elementsToDelete[j] + nextScene].omitted){
			// 	Beat.custom.unOmitScene([elementsToDelete[j] + nextScene], true)			
			// 	nextSceneIsOmitted = true
			// }

			// NOTE: i in omit-function kills i here! Changed to j

			endPosition = outline[elementsToDelete[j] + nextScene] ? (outline[elementsToDelete[j] + nextScene].position) : Beat.getText().length //moved out from "check for synopsis" loop because un-omitting may change value of position
			let theLength = Math.max((endPosition - outline[elementsToDelete[j]].position), outline[elementsToDelete[j]].length)
			
			//new: check for omission marks in string:
			restoreOmissionMark = ""
			checkString = outline[elementsToDelete[j]].line.string
			if(checkString.includes("*/") && !checkString.includes("/*")) restoreOmissionMark = "*/"
			if(checkString.includes("/*") && !checkString.includes("*/")) restoreOmissionMark = "/*"

			Beat.replaceRange(outline[elementsToDelete[j]].position, theLength - 1, "" + restoreOmissionMark) //the minus 1 here is to leave a CR or next scene may disappear
		
			// if(nextSceneIsOmitted){
			// 	Beat.custom.omitScene(false, [elementsToDelete[j]], true) // and NOT nextScene, because one scene is now removed!
			// 	nextSceneIsOmitted = false
			// }
		}
}

Beat.custom.checkBlankLines = function(position){

	//used when calling from HTML
	checkForDoubleBlankLines(position)

}

function checkForDoubleBlankLines(position){

	let parser = Beat.currentParser
	let rangeToCheck = 15 //this is how many lines back and forwards to look

	for (dbl = 0; dbl < rangeToCheck; dbl ++){

		let indexOfLineAbove = JSON.parse(JSON.stringify(parser.lineAtPosition(position - 1)?.position || 0))

		let lineAbove = parser.lineAtPosition(indexOfLineAbove)?.typeAsString()
		let line = parser.lineAtPosition(position)?.typeAsString()

		if (line == "Empty" && lineAbove == "Empty" && position < Beat.getText().length){
			Beat.replaceRange(position, 1, "")
		}

		position --
	}
}

Beat.custom.moveScenes = function(firstScene, lastScene, insertBeforeScene, warningsAreOn, startPosition, endPosition, synopsisMove, makeCopy){

	const outline = [...Beat.outline()]

	if(synopsisMove){
		warningsAreOn = false
	}

	if(warningsAreOn){

		let rangeOfScenes = ""
		let numberOfScenesToMove = 0
		for (scenes = firstScene; scenes<lastScene+1; scenes++){
			if(outline[scenes].typeAsString() == "Synopse"){continue}
			rangeOfScenes +=
			((outline[scenes].sceneNumber != undefined) ? 
				"(" + outline[scenes].sceneNumber + ") " : 
				"") +
				outline[scenes].string.toUpperCase().replace(/\[\[.*\]\]/, "") + "\n" +
				((outline[scenes].sceneNumber == undefined) ? 
				"\ncontaining\n\n" : 
				"")
				numberOfScenesToMove++
		}
		
		let doMove = Beat.modal({
			title: "Confirm Move",
			info: "\nYou are about to move " + 
					((outline[firstScene].typeAsString() != "Section") ?
						"the scene" 
						: "the section") +
					(((outline[firstScene].typeAsString() != "Section") && numberOfScenesToMove > 1) ? 
						"s" 
						: "") +
					"\n" + 
					(((outline[firstScene].typeAsString() != "Section")) ? 
						rangeOfScenes 
						: (outline[firstScene].string.toUpperCase().replace(/\[\[.*\]\]/, "")) + "\n") + 
					((outline[insertBeforeScene]) ? 
						("to immediately before\n" + 
						(outline[insertBeforeScene].omitted == 1 ? "the omitted scene called \n" 
						: "") +
					(((outline[insertBeforeScene] && outline[insertBeforeScene].typeAsString() == "Heading") 
						? ("(" + outline[insertBeforeScene].sceneNumber + ") ") : "") +
						outline[insertBeforeScene].string.toUpperCase().replace(/\[\[.*\]\]/, "")))
						: "\nto immediately after the last scene of your script.")
					+ 
					"\n\nDo you want to proceed?\n",
			items: [
				{
					type: "checkbox",
					name: "turnOffWarnings",
					label: "Turn off all warnings in the future"
				},
			]
		}, response => {
			
			if (response) {
				// The user clicked OK
				doMove = true
				if (response.turnOffWarnings == true) {
					Beat.custom.sendToMain("warningsAreOn", false, "userDefault")
				}
				return true
			} else {
				// The user clicked CANCEL
				return false
			}
		})
	
		if (!doMove){
			htmlWindow.runJS(`onDragEnd(false, true)`)
			return
		}
	}

	if(!makeCopy) htmlWindow.runJS(`ifYesToMove()`)

	//catch-all to make end of selection not out-of-range
	endPosition = Math.min(endPosition, Beat.getText().length)

	var theTextToMove

	let movedTextIncludesOmittedScene = Beat.outline().find(scene => scene.omitted == 1 && scene.position >= startPosition && scene.position <= endPosition)

	//first of all all all: synopsismove. Which is its own thing now.
	if (synopsisMove){

		insertionPosition = synopsisMove
		theTextToMove = Beat.getText().substring(startPosition, endPosition)

		if (insertionPosition < startPosition) {
			if(!makeCopy) deleteTheOldText()
			checkForDoubleBlankLines(startPosition + 1)
			addTheTextAtNewPosition()
			checkForDoubleBlankLines(insertionPosition + theTextToMove.length + 4)
		}
		
		if (insertionPosition > endPosition) {
			addTheTextAtNewPosition()
			checkForDoubleBlankLines(insertionPosition + theTextToMove.length + 4)			
			if(!makeCopy) deleteTheOldText()
			checkForDoubleBlankLines(startPosition + 1)
		}


	}else{ //the rest is for non-synopsis!

		//THIS CHECK should be redundant because made in the HTML already
		//but currently leaving it in for good measure even though it can't happen
		let sceneBelowDroppedWasOmitted = (outline[insertBeforeScene] && outline[insertBeforeScene].omitted == 1)
		let sceneAboveDroppedWasOmitted = (outline[insertBeforeScene - 1]?.omitted == 1)
			if(sceneBelowDroppedWasOmitted || sceneAboveDroppedWasOmitted){
				Beat.alert("Cannot drop immediately before or after an omitted (hidden) scene", "Due to the fountain logic for hiding scenes, dropping scenes adjacent to hidden ones is a very risky business that may end up hiding text you want to display, or showing text you dont.\n\nPlease manually unhide or delete the hidden scenes before moving scenes around.")
				htmlWindow.runJS(`onDragEnd(false, true)`)
				return
			}

		// commented out: do not un-omit scenes programatically!
			// if (sceneBelowDroppedWasOmitted){
			// 	this.unOmitScene([insertBeforeScene], true)
			// }
			// if (sceneAboveDroppedWasOmitted){
			// 	this.unOmitScene([theSceneAbove], true)
			// }

		//This un-omitting code has been commented out because it caused serious problems when moving omitted scenes!
			// //first check so that we don't break omitted scenes!
			// //unomitting and reomitting the scene before will make sure it stays intact.
			// 	if(outline[firstScene - 1] && outline[firstScene - 1].omitted){
			// 		Beat.custom.unOmitScene([firstScene - 1])
			// 		Beat.custom.omitScene(0, [firstScene - 1])
			// 	}
			// //then, we need to unomit the scene after, but re-omit it once the scenes are moved
			// 	let firstSceneAfterWasOmitted = false
			// 	if(outline[lastScene + 1] && outline[lastScene + 1].omitted){
			// 		firstSceneAfterWasOmitted = true
			// 		Beat.custom.unOmitScene([lastScene+1])
			// 	}
		
		//collect insertion point
		var insertionPosition = outline[insertBeforeScene] ? outline[insertBeforeScene].position : Beat.getText().length

		//copy text from that range
		var theTextToMove = Beat.getText().substring(startPosition, endPosition)

		//Further commenting out of omitting-related code
			// //NOW, re-omit the scene after the range.
			// if (firstSceneAfterWasOmitted){
			// 	Beat.custom.omitScene(0, [lastScene+1], true) 
			// 	//NOTE: even if doing this BEFORE moving, it should work fine because we retrieved endPosition already
			// }

		//insert and delete, or delete and insert, depending on wheter move was up or down

		let theNewOutlineNumberForFirstMovedScene
		
		if (insertionPosition < startPosition) {
			if(!makeCopy) deleteTheOldText()
			addTheTextAtNewPosition()

			theNewOutlineNumberForFirstMovedScene = insertBeforeScene
		}

		if (insertionPosition > endPosition) {
			addTheTextAtNewPosition()
			if(!makeCopy) deleteTheOldText()
			
			if(!makeCopy){
				theNewOutlineNumberForFirstMovedScene = insertBeforeScene - (lastScene - firstScene) - 1
			}else{
				theNewOutlineNumberForFirstMovedScene = insertBeforeScene //because if copy, then nothing is deleted
			}
		}

		if (sceneBelowDroppedWasOmitted){
			Beat.custom.omitScene(0, [(theNewOutlineNumberForFirstMovedScene + lastScene - firstScene + 1)] ,true)
		}
		if (sceneAboveDroppedWasOmitted){
			let theSceneAboveInserted = theNewOutlineNumberForFirstMovedScene -1
			while (outline[theSceneAboveInserted].typeAsString() == "Synopse"){theSceneAboveInserted --}
			Beat.custom.omitScene(0, [theSceneAboveInserted], true)
		}
	}

	if (movedTextIncludesOmittedScene){
		Beat.alert("Wait, wait, wait â€” did I just move a hidden (omitted) scene too?", "Yes, you did. Sorry about that. But since a hidden scene just means that there is an omission starting SOMEWHERE in the previous scene, all kinds of weird things could happen if we didn't (including un-omitting the hidden scene, or leaving behind some hidden text that should rather have moved along with the scene).\n\nPlease take a second to check if you need to move any hidden material back to where it was.")
	}
	
	//finally (2) here are some scope-only functions for inserting and deleting.

		function addTheTextAtNewPosition(){

			let parser = Beat.currentParser
			let potentialExtraEmptyFirstLine = ""
			let potentialExtraEmptyLastLine = ""
			// if (parser.lineAtPosition(insertionPosition - 1).string != ""){
			if (insertionPosition > 0 && parser.lineAtPosition(insertionPosition - 1).typeAsString != "Empty"){
				potentialExtraEmptyFirstLine = "\n"
			}

			while (theTextToMove.concat(potentialExtraEmptyLastLine).substr(theTextToMove.concat(potentialExtraEmptyLastLine).length - 2, 2) != "\n\n"){
				potentialExtraEmptyLastLine += "\n"
			}

			Beat.addString(potentialExtraEmptyFirstLine + theTextToMove + potentialExtraEmptyLastLine, insertionPosition)

			checkForDoubleBlankLines(insertionPosition)
		}

		function deleteTheOldText(){
			Beat.replaceRange(startPosition, endPosition-startPosition, "")
			
			checkForDoubleBlankLines(startPosition)
		}
}

Beat.custom.reallyQuit = function (noconfirm) {

	let quit = false

	if(!noconfirm){
		quit = Beat.confirm("Do you really want to close FTOutliner?", "All your work is stored in Beat, so no harm done. It's just that it's so easy to hit Escape once too many. That's all.\n\nGo ahead and close?")
	}
	if(quit || noconfirm){
		htmlWindow.close()
	}

}

function ____________________PRINT_AND_EXPORT___________________(){}


Beat.custom.exportThis = function (content, classListOfFlexiContainer, documentName, documentSubName, documentAuthor) {

	let pathToCSS = `/Users/fredriktolsson/Library/Containers/fi.KAPITAN.Beat/Data/Library/Application Support/Beat/Plugins/FTOutliner.beatPlugin/`

	let	output = `
		<!DOCTYPE html>
		<html>
		<head>
		<link rel="stylesheet" href="`+pathToCSS+`outline.css">
		<link rel="stylesheet" href="`+pathToCSS+`indexCards.html"></link>
		<link rel="stylesheet" href="`+pathToCSS+`charactertracking.html"></link>
		</head>
		<meta charset='UTF-8'>
		<body>`+
		((documentName) ? `<p class="headline">` + documentName.toUpperCase() + `</p>`: ``)
		+
		((documentSubName) ? `<p class="headline2">`+ documentSubName + `</p>`: ``)
		+
		`<div id='flexiContainer' class='` + classListOfFlexiContainer + `'>` + //`' style = "outline: 1px lime solid; height: 80vh !important">` +
		content +
		`</div>
		<p class="footer"><span style="float:right">Created using BEAT and the FTOUTLINER plugin.</span><span style="float:left">Writer: ` + documentAuthor + `</span><br/>
		<span style="opacity: 0.2; float:right">` + new Date() + `</p>
		</body></html>`

	Beat.saveFile("html", function (filePath) {

		Beat.writeToFile(filePath, output)
	 })
	
}


Beat.custom.printThis = function (content, classListOfFlexiContainer, documentName, documentSubName, documentAuthor) {

	let css = Beat.assetAsString("outline.css")
	let printCSS = Beat.assetAsString("printOutlineCSS.css")
	let notepanel = Beat.assetAsString("notepanel.html")

	if (!documentName){
		let message1 = "Print outline without title?"
		let message2 = "FTOutliner could not find the title for your screenplay. Hit cancel to open the settings dialog and enter some info, or OK to print anyway."
		let printAnyway = Beat.confirm(message1, message2)

		if(!printAnyway){
			htmlWindow.runJS("newPrintBox()")
			return
		}
	}

	let	output = /*html*/`
		<!DOCTYPE html>
		<html>
		<meta charset='UTF-8'>
		<body>
		${css}  
		${printCSS}  
		${notepanel}
			<div id="outerEdge">
				<p class="headline"> ${documentName ? documentName.toUpperCase() : ""} </p>
				<p class="headline2"> ${documentSubName ? documentSubName : ""} </p>
					<div id="flexiContainer" class="${classListOfFlexiContainer}">
						${content} 
					</div>
			<div>
			<p class="footer"><span style="float:right">Created using BEAT and the FTOUTLINER plugin.</span><span style="float:left">${documentAuthor? "Writer: " + documentAuthor : ""}</span><br/>
			<span style="opacity: 0.2; float:right">${new Date()}</p>
		</body>
		</html>
		`

		// never turn this on except for bugging purposes!
		// opens the print-html in a new beat document
		// Beat.newDocument(output)

	Beat.printHTML(output, 
		{
			orientation: "portrait", // default is portrait
			paperSize: "a4" // default SHOULD be document setting
		}, 
			function(){htmlWindow.runJS(`togglePrintMode()`)}
	)		
}

Beat.custom.setTheWindowTitle = function(){
	setWindowTitle()
}

function setWindowTitle() {

	windowTitle = "FTOutliner"

	let titlePageLines = Beat.lines()?.filter(line => line.isTitlePage)
	let title = titlePageLines?.find(line => line.string?.toLowerCase().startsWith("title:"))?.string?.replace(/title:/i, "").trim().toUpperCase() || false

	let documentSetting = JSON.parse(Beat.getDocumentSetting("ftoutlinerObject") || "{}")

	let documentName = documentSetting?.documentName || title || ""
	let documentSubName = documentSetting?.documentSubName || ""
	let documentAuthor = documentSetting?.documentAuthor || ""

	// Beat.alert(documentName, documentSubName, documentAuthor)

	if(documentName) documentName = documentName.replaceAll(/\*/g, "")
	if(documentSubName)documentSubName =documentSubName.replaceAll(/\*/g, "")
	if(documentAuthor)documentAuthor = documentAuthor.replaceAll(/\*/g, "")

	if (documentName){windowTitle += " â€” " + documentName}
	if (documentName && documentSubName){windowTitle += " (" + documentSubName + ")"}
	if (windowTitle){htmlWindow.title = windowTitle}

}

Beat.custom.blinkTheLine = function(start, end, color, textcolor){

	if(Beat.currentParser.lineAtIndex(start) == null){
		Beat.crash()
	}

	// if (start == Beat.currentParser.lineAtIndex(start)?.position && end == Beat.currentParser.lineAtIndex(start)?.range.length){
	// 	end ++} //adds extra character to include CR if full line

	Beat.timer(0.25, function () {
		Beat.textBackgroundHighlight(color, start, end)
		if(textcolor){Beat.textHighlight("#222222", start, end)}
		Beat.timer(0.25, function () {

			Beat.reformatRange(start,end)

			Beat.timer(0.25, function () {
				Beat.textBackgroundHighlight(color, start, end)
				if(textcolor){Beat.textHighlight("#222222", start, end)}
				Beat.timer(0.25, function () {

					Beat.reformatRange(start,end)

					Beat.timer(0.25, function () {
						Beat.textBackgroundHighlight(color, start, end)
						if(textcolor){Beat.textHighlight("#222222", start, end)}
						Beat.timer(0.25, function () {

							Beat.reformatRange(start,end)

						})
					})
				})
			})
		})
	})
	
}

Beat.custom.sendTextToHTML = function(startIndex, endIndex){
	allText = Beat.getText()
	htmlWindow.runJS("receiveText(`" + allText + "`," + startIndex + "," + endIndex + ")")
}

Beat.custom.sendChangelogToDialog = function(){

	let message = Beat.assetAsString("changelog")

	// Beat.alert(message)

	let jsToRun = `displayAnyBox(${JSON.stringify(message)})`
	
	htmlWindow.runJS(jsToRun)

}

Beat.custom.copyRangeToClipboard = function(ranges){

	let allText = Beat.getText()
	let textToCopy = ""
	ranges = JSON.parse(ranges)
	// Beat.alert(ranges)

	for (range of ranges){

		// Beat.alert(range.start, range.end)

		textToCopy += allText.substring(range.start, range.end) + "\n\n"
	}

	Beat.newDocument(textToCopy)

}

Beat.custom.collectRevisionsInPlugin = function(){

let timeIn = Date.now()
    
        let indexObject = (Beat.getRawDocumentSetting("Changed Indices"))
        let reviewObject = (Beat.getRawDocumentSetting("Revision"))

		let indexAsJSON = JSON.stringify(indexObject)
		let reviewAsJSON = JSON.stringify(reviewObject)		
    
        //Beat.log(indexAsJSON)
        //Beat.log(reviewAsJSON)

		htmlWindow.runJS(`
			paintRevisions('${indexAsJSON}', '${reviewAsJSON}')
		`)

		let timeOut = Date.now() - timeIn
			htmlWindow.runJS(`console.log("${timeOut} ms")`)

}

Beat.custom.collectReviews = function(andThenCreateDoc){

	let reviews = Beat.getRawDocumentSetting("Review Ranges")
	let allText = Beat.getText()

		if (reviews.length == 0) return

		let outline = Beat.outline()
		let reviewNumber = 0

		for (element of outline){

			if (reviews[reviewNumber]?.range[0] >= element.position) continue
			
			while (reviewNumber < (reviews.length - 0) && reviews[reviewNumber]?.range[0] < element.position){
				
				reviews[reviewNumber].outlineElementNumber = outline.indexOf(element) - 1

				if(allText.substr(reviews[reviewNumber].range[0] + reviews[reviewNumber].range[1], 1) == "\n"){
					reviews[reviewNumber].range[1] --
				}

				reviewNumber ++

			}


		}

		if (!reviews[reviews.length - 1].outlineElementNumber){
			x = 1
			while (outline[outline.length - x].typeAsString() != "Heading") x ++
			reviews[reviews.length - 1].outlineElementNumber = outline.length - x
		}

		for (review of reviews){
			review.position = review.range[0]
		}

		reviews = JSON.stringify(reviews)

	if(andThenCreateDoc){
		htmlWindow.runJS(`createDocFromReviews(${reviews})`)
	}else{
		htmlWindow.runJS(`displayReviews(${reviews})`)
	}

}

Beat.custom.outlineToJSON = function(){
	
	let a = Beat.outlineAsJSON()
	Beat.newDocument(a)

	let b = Beat.linesAsJSON()
	Beat.newDocument(b)

}

Beat.custom.makeWindowsShareScreen = function(availHeight, availWidth){
	if (Beat.iOS()) return;

	let splitX = availWidth/2
	let splitY = availHeight/2
	
	htmlWindow.setFrame(0, 0, splitX, availHeight)
	Beat.setWindowFrame(splitX + 1, 0, availWidth/2, availHeight)

}

Beat.custom.setWindowSize = function(x, y, width, height) {
	if (Beat.iOS()) return;
	htmlWindow.setFrame(x, y, Math.max(width, 380), height)
}

Beat.custom.toggleFull = function(){

	htmlWindow.toggleFullScreen()

}

Beat.custom.runHightlightCharacter = function(name){

	//this only for relaying when sent from the dropdown list.
	highlightCharacter(name)
	
}

function highlightCharacter(name, onlyHighlightScenes, straightFromEditorWindow){ //if no name here, it means we came not from dropdown list but editor

	let line = Beat.currentLine
	
	if(!name){

		name = "ALL"
				
		if(["Character", "Dialogue", "Parenthetical"].includes(line.typeAsString())) {
			while(line.typeAsString() != "Character" && line.position > 1){
				pos = line.position - 1
				line = Beat.lineAtPosition(pos)
			}
			name = (line.typeAsString() == "Character") ? line.string.replace(/\(.*\)/, "").trim().toUpperCase() : "ALL"
		}

		if(onlyHighlightScenes){			
			let jsToRun = `toggleSoloCharacter(0, "${name}")`
			htmlWindow.runJS(jsToRun)
			return
		}

		htmlWindow.runJS(/*html*/`
			cycleTabs($(".dialogtab"))
			initiateCharacterBubbles("${name}")
			updateDialogPanelSelection()
			`)
			return
	}


	Beat.dispatch(function(){	

		let outline = Beat.outline()
		let dialogForCharacter = []
		let collect = false

		for (element of outline){

			let linesForScene = Beat.linesForScene(element)
			let dialogInScene = []

			for (line of linesForScene){

				let currentLine = false
				if (line == Beat.currentLine) currentLine = true

				let stringToCompare = line.string
					if (line.typeAsString() == "Character") stringToCompare = line.string.replace(/\(.*\)/, "").trim()
				
				//Turn collection ON
					if (line.typeAsString() == "Character" && (name.toUpperCase() == "ALL" || stringToCompare.toUpperCase() == name.toUpperCase())) collect = true
				//Turn collection OFF 
					if (!["Character", "Dialogue", "Parenthetical"].includes(line.typeAsString())) collect = false
					if (line.typeAsString() == "Character" && (name.toUpperCase() != "ALL" && stringToCompare.toUpperCase() != name.toUpperCase())) collect = false

				if (collect) dialogInScene.push({
					"position": line.position,
					"string": line.string, 
					"typeAsString": line.typeAsString(),
					"omitted": line.omitted,
					"currentLine": currentLine,
				})
			}
			dialogForCharacter.push(dialogInScene)
		}

		Beat.dispatch_sync(function(){
			jsToRun = `
				showCharacterBubbles(${JSON.stringify(dialogForCharacter)}, ${JSON.stringify(name.toUpperCase())})
				`
			if(straightFromEditorWindow) jsToRun += /*html*/`
				setTimeout(function(){scrollNicelyIntoView($(".hasCursor"), $id("dialogpanelcontent"))}, 200)
			`
			htmlWindow.runJS(jsToRun)
		})

	})

}
